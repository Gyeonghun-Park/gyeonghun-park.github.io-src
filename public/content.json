{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"[Leetcode] 125. Valid Palindrome","text":"문제 주어진 문자열이 팰린드롬인지 확인하라. 대소문자를 구분하지 않으며, 영문자와 숫자만을 대상으로 한다. 예제 제약 풀이Regular expression (정규 표현식)을 사용해 불피요한 문자를 제거하고, Slicing [::-1]을 이용하여문자열을 뒤집었다. 123456def isPalindrome(self, s: str) -&gt; bool: s = s.lower() # 정규식으로 불필요한 문자 필터링 s = re.sub('[^a-z0-9]', '', s) return s == s[::-1]","link":"/2021/12/06/Leetcode-125-Valid-Palindrome/"},{"title":"[Blockchain] 블록체인과 암호화폐 복습","text":"화폐의 기능 세 가지는 무엇인가요? 교환의 매개체 물물교환의 불편함을 없애고 물건을 교환 가능 가치 척도의 기준 물건의 가치를 정하는 잣대의 기능 가치 저장의 기능 가치를 저장하는 수단으로 활용 가능 암호화폐는 화폐의 기능을 모두 만족하나요?현재로서는 세가지중 교환의 매개체, 가치 저장의 기능 두가지 기능만 만족을 한다. 큰 변동성으로 인해서 가치 척도의 기준은 만족하지 못한다. 본원통화로부터 신용 화폐는 어떻게 만들어지나요?기본적으로 은행에 예금하는 행위로 인해서 만들어 진다. 사용자가 은행에 돈을 예금하게 되면 은행은 그돈을 이용해 대출을 진행하고 그 과정이 반복되어서 신용화폐가 만들어 지게 되며 이것이 지속적으로 발행하면 전체 통화량이 본원 통화보다 더 많이 증가하게 된다. 전체 통화량이 본원 통화보다 많아지는 이유는 무엇인가요?전과 같은 이유이다. 통화량이 늘어나면 왜 인플레이션이 발생하나요?통화량이 늘어난다는 뜻은 돈이 많이 풀린다는 의미이고 돈이 많이 풀린다는 것은 그만큼 소비가 증가한다는 소리이다. 하지만 반대로 돈의 가치가 떨어진다는 의미도 되며 상품은 많은 소비로 인해서 점점 가치가 상승하는데 화폐는 너무 많다보니 화폐의 가치는 떨어지고 물가는 상승하게 된다. 이로 인해서 인플레이션이 발생한다. 중앙은행은 어떻게 통화량을 조절하나요?돈을 발행하는행위를 통해서 통화량을 조절한다. 1차 세계대전 이후 독일의 초인플레이션 양상은 어떠했으며, 어떻게 인플레이션에서 벗어날 수 있었나요?대표적인 초인플레이션 사례이다. 독일은 전쟁 비용을 부채로 부담을 하였고 이로인해 국가에 빛이 많이 생기게 된다. 하지만 전쟁의 여파로 인해 국가내에 돈이 들어가야 할 곳이 많았고 그것을 처리하기 위해 통화량을 급등시키기 시작한다. 이로 인해서 인플레이션이 발생을 하였다. 그러기 떄문에 독일 정부는 새로운 화폐를 제한된 통화량을 통해 인플레이션을 벗어날수 있었다. 2008년 서브프라임 모기시 사태에서, 금융위기를 해결하기 위한 미 연방준비제도는 어떤 정책을 펼쳤나요? 또한 이 정책의 문제점은 무엇인가요?양적 완화라는 정책을 시도 하였다. 화폐를 대량으로 찍어내 순식간에 통화량을 늘려서 급한 불을 끄는 정책이다. 하지만 통화량의 급증으로 인해 물가는 상승하게 되었고 결과적으로는 해결이 되었지만 그 과정에서 일반인들은 많은 피해를 받게 되었고 이로 인해 정부에 불만이 생기게 된다. 블록체인에서 블록과 체인은 각각 무엇인가요?블록은 트랜잭션을 저장하는 데이터 공간이다. 그리고 체인은 이러한 블록을 연결하는 것을 말한다. 비트코인 같은 경우에는 거래기록이라는 트랜잭션을 블록에 저장하게 되며 채굴이라는 과정을 통해서 블록이 생성되고 이 블록은 이전 블록을 가르키는 데이터를 가지고 있다. 비트코인앞서 설명을 했듯이 사용자간의 거래기록을 담고 있는 블록을 지닌 코인이다. 코인이 채굴이 되게 되면 블록이 만들어 지게 되며 채굴자 노드에게는 보상으로 코인이 지급되는 거을 이용한다. 이더리움비트코인보다 더 많은 기능을 하는 코인이라고 생각을 하면 된다. 비트 코인같은 경우에는 블록에 거래기록만을 저장을 하였지만 이더리운은 거래기록을 포함하여 추가로 데이터를 저장할수 있는 코인을 말하며 이러한 블록체인을 이용하는 애플리케이션을 DAPP라고 한다. 기존 전자 금융 시스템과 비트코인의 차이점은 무엇인가요?기본적으로 어떤 신뢰를 바탕으로 거래가 이루어지냐의 문제이다. 기존 전자 금융 시스템은 특정기업, 또는 특정 정부를 신뢰하여 신뢰하는 기관에서 찍어낸 화폐만 이용을 하였지만 비트코인같은 디지털 화폐는 모든 네트워크 사용자들이 공유를 하기 떄문에 특정 기업, 정부를 신뢰하는 것이 아니라 네트워크 사용자들을 신뢰하여 사용을 하는 것이다.","link":"/2021/12/10/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8%EA%B3%BC-%EC%95%94%ED%98%B8%ED%99%94%ED%8F%90-%EC%9A%94%EC%95%BD/"},{"title":"[Blockchain] 블록체인과 암호화폐","text":"📕 개요 기존의 금융 시스템을 이해 기존 금융 시스템의 문제점 핵심 블록체인 기술의 이해 주요 암호화폐들의 등장 원인 💵 기존의 금융 시스템화페의 역사화폐는 다양한 형태로 변하해 왔다. ex) 물물교환, 가치를 통한 거래, 지폐 등등 계속하여 단점들을 보완하며 현재 우리가 쓰고 있는 종이 화폐까지 발전을 하였다. 하지만 우리는 이러한 지폐가 다른 상품과 실제로 동등한 가치를 가진다는 것은 아니라는 것을 알고있다. ex) 사과 한개와 천원짜리의 실질적인 가치는 다르다. 그래서 지폐의 가치를 보완해주기 위한 것이 국가 또는 은행의 신용(신용화폐)이다. 신용화폐는 다음의 규칙을 만족해야 한다. 휴대성 휴대가 용이 함 가분성 분할에 용이함 내구성 형태가 쉽게 변하지 않음 동질성 같은 성질이나, 특성, 모양이 모두 같아야함 가치의 안정성 공급량이 제한되어 있음 화폐의 기능화폐를 사용함으로써 얻을수 있는 주요한 기능들은 무엇이 있을까 앞서 말했듯이 신용화폐 즉 우리가 현재 사용하고 있는 종이화페는 중앙기관의 신뢰를 바탕으로 가치가 증명이 가능하다. 이런 화폐는 크게 3가지의 주요한 기능을 하게 된다. 교환의 매개체 물물교환의 불편함을 없애고 편히 물건을 교환할 수 있는 기능 단순히 같은 물건이 아니라도 교환이 가능 농부과 어부가 서로 화폐를 가지고 거래를 하는 것 처럼 가치척도의 기능 물건의 가치를 정하는 잣대의 기능을 할수가 있다. 예를들면 커피는 3천원 같은 가치를 정한다. 가치 저장 기능 가치를 저장하는 수단이 되기도 한다. 쌀을 보관하는 것보다 화폐를 보관하는 것이 좀더 편할 것이다. 화폐의 기능으로 본 암호화폐앞서 말햇듯이 화폐는 3가지의 주요한 기능과 5가지의 규칙을 만족 하여야한다. 그럼 우리가 알고 있는 대표적인 암호화폐인 비트코인을 예로 들어서 알아보자. 현 시점에서도 여전히 화폐로서의 노란은 끊임이 없다. 가치척도의 기능을 정상적으로 수행하지 못해, 아직은 가능성만 있는 상태이다. 전에는 우리는 코인을 통해서 무언가를 구매할수가 없었다. 하지만 최근 들어서 페이팔 등 글로벌 핀테크 업체들이 코인을 통한 결제를 지원하기 시작하였고 이로 인해서 교환의 매개체 기능을 정상적으로 수행하고 있다는 것을 알수 있다. 우리는 비트코인의 심각한 변동성을 알고 있고, 이러한 이유로 인해서 현재로서는 가치척도의 기능을 정상적으로 수행하지는 못할 것이다. 이를 해결하고자 등장한 것들중 하나가 스테이블 코인이다. 세간에서는 비트코인이 디지털 화폐가 아니라 디지털 자산으로 이용해야 한다고 주장을 한다. 즉, 금과 같은 가치 저장의 수단으로 조명받고 있는 것이다. 🤔 기존의 금융 시스템의 문제점앞서 말한 신용화폐의 문제점을 알아보고 이에 따른 디지털 화폐에 대해 알아보자 신용 창출은행을 통해 국가에 유통되는 화폐량이 늘어가는 현상을 말한다. 예를들면 A는 중앙은행에서 1억원을 대출해 x라는 은행에 예금을 하였다. 급하게 A가 돈이 필요해 돈을 인출해 갈수 있기 때문에 x은행은 20%만 따로 뗴어두고 나머지 돈은 B라는 사람에게 대출을 해준다. 역시 B도 y라는 은행에 예금을 하게 되면 y은행은 20%를 남겨두고 다른 사람들에게 대출을 해주게 된다. 이러한 예시가 계속해서 반복된다고 생각을 해보자. 이러한 과정이 진행되게 되면 중앙은행에서는 1억원을 통화시켯지만 모든 은행에 예금된 금액을 합치면 총 2억4천4백만원이 되게 된다. 이러한 과정이 무한으로 반복되면 은행에 예금된 금액은 점점 증가하게 될것이고 무한등비급수를 활용해 구해보면 총 예금된 금액은 5억원이 될 것이다. 즉 1억원을 통해 시중에 유통된 돈이 5억원이 되었다. 여기서 1억원을 본원통화 라고 하며 나머지 4억원을 신용화폐라고 한다. 우리가 실제 빌린돈은 1억원인데 사용하는 금액은 총 5억원이 되었다. 즉 본원통화로부터 신용화폐가 만들어지며 전체 통화량이 본원통화보다 더 많이 증가하게 된다. 통화량과 인플레이션그럼 통화량이 늘어난다는 것은 시중에 돈이 많이 풀린 다는 것을 알수가 있을 것이다. 통화량이 늘어나게 되면 개인의 소득 역시 증가하게 되고 수입이 많아지게 되면 소비량도 같이 증가하게 된다. 하지만 반대로 소비량은 증가하지만 상품에 대한 공급량은 통화량에 맞게 증가하지 않기 떄문에 상품이 가지는 가치는 증가하게 될 것이며 상품의 가격은 상승하게 될 것이다. 이를 인플레이션 이라고 한다. 인플레이션이 발생하면 사람들은 더 적은 물건을 사게 될것이지만 반대로 부동산 등 자산이 많은 사람은 자신의 상품의 가치도 오르기 떄문에 별다른 타격이 없을 것이다. 이러한 격차를 막기 위해서 화폐의 독점적 발행권을 가진 중앙은행이 신중하게 통화량을 조절 해야 한다. 인플레이션 사례대표적으로 1차 세계대전에서 독일이 있다. 독일은 전쟁 비용을 세금이 아닌 국채 발행으로 충당을 하였고 전쟁이 길어짐에 따라 독일 정부의 지출이 증가하게 되었다. 이로인해 부채(빛)이 증가하게 되었고 독일의 필요한 예산또한 증가하게 되어서 독일은 초인플레이션이 시작되었다. 일단 전쟁배상금, 사회기반 복구 등등 돈이 많이 필요하기 떄문에 중앙은행에서 화폐를 마구 찍어내기 시작하였고 통화량이 급등하자 물가도 급등하게 되었다.하지만 반대로 상품 공급은 제대로 이루어 지지 않았다. 이로 인해서 물가가 상승할수록 화폐의 가치는 떨어지게 되고 기업들은 돈을 벌기 보다는 부동산을 통해서 자산을 늘리기 시작하였다. 이로인해 독일내에서 외국자본 또한 빠져나가게 되었고 환율 또한 절하 되게 되었다.이로인해 수입물가가 상승해 또 인플레이션이 발생하게 된다. 독일 정부는 새로운 화폐를 발행 시켜 통화량을 한정 시켰고 이로 인해 국민들은 새로운 화폐를 믿고 사용하기 시작했다. 돈을 마구 발행하면 아무도 그 돈이 가치가 있다고 느끼지 않겠지만, 한정량을 발행하여 사용하면 가치가 있다고 느껴 신뢰를 가지게 될 것이다. 신뢰를 지키지 못한 정책 사례대표적으로 세계금융위기가 있다. 세계금융위기의 상징은 리먼 브라더스의 파산이 있다. 미국의 집값의 하락의 주택의 가치가 떨어지고 이는 새로운 대출 상품의 한도를 줄이게 만들었다. 이로인해 사용자들은 이율이 낮은 새로운 대출로 옮겨 가야했고 저소득층 주택담보대출의 상환률이 급격하게 감소하기 시작하였다. 주택을 담보로 돈을 빌려줬던 은행들은 단기간에 돈을 회수하고 다시 빌려주고자 MBS(주택을 담보로 하는 채권)라는 상품을 만들었다. 전체 이자보다는 적지만 짧은 시간안에 수익을 남기고, 투자자는 시간이 오래걸리지만 원금과 이자를 얻는 구조이다. 하지만 이러한 공식이 성립이 되려면 집값이 계속 증가를 해야하는데 집값의 지속적인 하락으로 인해 급격한 유동성 위기에 빠지게 된다. 연준의 해결책양적완화 라는 정책을 시도한다. 금리 수진이 너무 낮아서 금리 인하를 통한 효과를 기대할 수 없을떄 중앙은행이 다양한 자산을 사들여 시중에 통화를 늘리는 정책 즉 쉽게 말해 화폐를 대량 찍어내 급한 불을 끄고 경제 회복을 하면 서서히 회수하여 지나친 물가 상승을 방지하는 전략 이 정책은 어느정도 잘 실행 되었다. 하지만 반대로 통화량을 찍어내면 문제가 발생한 다는 것을 앞선 글을 통해 알수가 있다. 인플레이션이 발생하기 시작하였고 일반인들에게는 마른 하늘의 날벼락 같을 것이였다. 즉 신뢰도를 잃게 되면서 중앙기관의 정책이 자산에 영향을 주는것에 불만을 가지게 된다. 이러한 이유로 인해 비트코인이 등장하게 되었다. 비트코인 백서에 다음과 같은 글이 있다. 전통적인 화폐가 가진 근원적인 문제는 필요한 신뢰 기관 자체이다. 중앙은행은 일반인들에게 신뢰를 주어야 하지만 법정화폐의 역사는 위반사례로 가득하다. 은행들은 돈을 보관하고 신뢰를 주어야 하지만 얼마 안되는 준비금(20%)만 남기고 나머지를 대출해 줌으로써 우리는 그들을 단순히 믿어야만 했고 그들을 신뢰 해야 했다. 🗂️ 자료구조로써의 블록체인본격적으로 학습하기 전에 블록체인이 무엇인지 알아보자. 블록체인의 핵심은 인터넷 상에 있는 모든 사람들이 동일한 데이터를 가지는 것이다. 누구나 데이터를 추가할 수 있다. 데이터는 한 번 추가되면, 수정하거나 삭제할 수 없다. 특정 개인, 단체가 관리하는 것이 아니라 모든 사람들이 함께 관리한다. 블록데이터를 저장하는 공간이다. ex) 자산에 대한 정보, 개인정보등을 암호화하여 담는다. 비트코인 같은 경우에는 블록에 거래 기록을 저장한다. 이 거래기록을 트랜잭션 이라고 한다. 추가로 자신의 소유권을 증명하기 위해 디지털 서명도 추가한다. 다시 말해 블록은 트랜잭션들을 담은 기록의 집합이다. 체인블록 하나에 모든 기록들을 담을수 없을 것이며 사람들이 동시에 한 블록에 기록을 하려고 하면 불편할 것이며, 블록에는 특정 기간 동안 발생한 거래 내역이 기록되어 있어야 한다. 예를들어, 만약 블록이 10분간의 거래를 기록한다면 블록 6개는 한시간의 거래를 기록 할 것이다. 또한 이 블록들은 인터넷을 통해 많은 사람들에게 공유 되어야 하는데, 블록에 담기는 트랜잭션 기간이 짧다면 블록의 크기는 줄고 더 자주 생성 될 것이다. 그러면 블록을 공유 받는 사용자들은 더 많은 블록들을 받아야 하기 떄문에 불편할 것이다. 반대로 블록의 크기가 커지게 되면 속도가 느려지게 될 것이다. 하나의 블록이 공유되면 그후의 블록은 이전에 공유된 블록을 가르키는 데이터를 넘어서 이전의 블록이 어떤 블록인지를 연결한다. 이렇게 블록이 생성 될때마다 블록안에 있는 트랜잭션들은 노드(클라이언트를 사용해 네트워크에 접속해 있는 컴퓨터)들의 다양한 검중을 거쳐 네트워크 사용자 들에게 공유가 되게 된다. 트랜잭션이 블록에 담기게 되고 블록이 체인에 추가되어 블록체인이라는 것을 구성을 하였을떄 모든 과정이 완료가 된다. 트랜잭션을 모아서 블록을 만드는 과정을 채굴이라고 한다. 채굴은 트랜잭션을 처리하는 작업이므로 시스템에서는 송금 처리를 말한다. 즉, 채굴은 송금 서비스를 운영하는 핵심이기 떄문에 보상이 주어지게 된다. 경쟁적으로 이루어 진다. 경쟁에 참여한 노드들은 저마다 블록을 만들어 네트워크에 전파가 되며 경쟁에서 승리한 노드가 생성한 블록을 사용하게 된다. 이후 블록을 받은 노드들은 해당 블록이 유효한지 확인하고 유효하다면 체인을 추가한다. 그후 블록을 생성한 노드는 코인을 받게 된다. 분산원장과 블록체인원장은 거래 내역의 집합이자 블록이라고 생각하자 블록체인은 원장을 저장하는 일종의 데이터베이스 이다. 원장을 가지고 있는 사용자들이 원장에 대해 동등한 권한을 가지고 있다고 생각해보자. 분산 원장은 분산되어 있으며 데이터를 여러 위치에 두거나 여러 사용자들이 나눠서 가지고 있는 데이터 베이스 유형이다. 또한 데이터를 저장하기 위해서는 공유하고 있는 당사자들이 합의를 해야한다. 합의를 통해 분산되어 있는 데이터베이스들이 하나의 인관된 데이터를 가지게 된다. 분산원장과 블록체인에는 차이점은 다음과 같다. 블록 구조 블록체인은 블록형태이지만 분산원장은 여러 노드에 데이터를 저장하는 데이터 베이스이다. 순서 블록체인은 순서대로 저장이 되지만 원장은 그렇치 않다. 블록 생성 메커니즘 블록체인에서는 노드를 정하기 위해 (PoW, PoS)같은 메커니즘을 사용하고 보통 자원을 소모한다. 하지만 분산원장에서는 경쟁을 하지 않는다. 토큰 블록체인에서는 보상으로 코인을 지급하고 화폐의 역할을 하게 된다. 만약 보상이 없다면 아무도 블록을 생성하지 않을 것이다. ₿ 비트코인비트코인은 중개자 없이 직접 화폐를 사거나 팔고, 환전 가능한 탈 중앙화된 디지털 화폐 시스템이다. 누구나 사용가능하지만 그 누구도 시스템에 제약을 걸수 없다. 기존 전자 금융 시스템에서는 은행 이라는 중개자를 통해서 신원을 증명 해야했고 은행이 해당 신원을 보관하고 있게 되었다. 하지만, 앞서 말한 금융위기를 보면서 은행이 올바른 선택을 하지 않는다는 것을 알수가 있었다. 그로인해 신뢰가 아닌 암호화 증명에 기반한 전자 결제 시스템이라는 목적으로 비트코인이 만들어 지게 되었다. 비트코인은 퍼블릭 블록체인으로 누구든지 접근 가능하지만 블록들은 해쉬값으로로 저장이 되며 트랜잭션이 조금이라도 변화가 발생하면 블록의 해쉬값 또헌 변화가 되기 때문에 안전하다고 할수 있다. ⧫ 이더리움비트코인은 단순히 자신의 거래 기록을 저장하는 용도이지만,이더리움은 거기에 더해 튜링완전성 프로그래밍이 가능하다. 거래기록 뿐만 아니라 더욱 다양한 데이터들을 저장하는 것이 가능해졌다. 즉 다른 디지털 자산이 활용이 가능해진다. 블록체인의 특성상 데이터의 안전성을 보장 하면서 작동을 한다. 비트코인과 이더리움의 가장 큰 차이점은 사요자들이 컴퓨터에서 소프트웨어 프로그램을 실행하는 것처럼 블록체인 위에서 실행되는 신뢰를 기반으로한 애플리케이션을 구축 가능하다. 스마트 컨트랙트블록에 코드를 담아 블록체인에 올리게 되면서 실행이 가능해지며, 중개자를 거치지 않고 당사자간 직접 계약을 체결하는 시스템을 말한다. 이렇게 블록체인 시스템 위에서 실행되는 어플리케이션을 DApp라고 한다 📖 요약화폐의 특성에는 휴대성, 가분성, 내구성, 동질성, 가치의 안전성 이 있다.주요 기능으로는 교환의 매개체, 가치 척도의 기능, 가치 저장의 기능이 있다. 비트코인 등장 배경대표적으로 금융 위기가 있다. 통화량 증가로 경제가 빠르게 회복 되었지만 물가상승또한 동반되어서 노동자들은 파산하게 된다. 즉 단일 기관의 정책이 화폐의 가치를 좌지우지하자 사람들은 중앙기관의 정책이 자신에게 큰 영향을 주는것에 대해 불만이 크가 증가하게 되었다. 비트코인은 이러한 문제를 해결하기위해 등장 하게 된다. 분산원장 vs 블록체인분산 원장 데이터를 분산하여 저장만 하면 되기 떄문에 구조가 다양함순서를 지키지 않음누가 데이터를 올리는지는 중요하지 않음보상이 없음 블록체인 블록의 형태로 데이터를 저장직전 블록을 가리킴으로써 순서를 지정함블록을 생성할 노드를 정하기 위해 자원을 소모(POW, POS)보상으로 코인이 제공됨","link":"/2021/12/07/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8%EA%B3%BC-%EC%95%94%ED%98%B8%ED%99%94%ED%8F%90/"},{"title":"[Blockchain] 블록체인 종류, 트랜잭션","text":"📕 개요블록체인은 P2P네트워크를 통해서 관리되는 거래 장부를 중앙화된 서버에 저장 하는 것이 아닌 네트워크에 연결된 다수의 여러 컴퓨터에 저장 및 관리 하는 기술이다. 제 3의 신용기관이 없어도 네트워크 참여자들 간의 신뢰있는 거래가 가능하며 탈중앙화, 수평적인 디지털 비지니스의 기반이 된다. 이번 포스트에서 블록체인의 다양한 기술들과 그것들 간의 연관성을 알아 볼 것이다. 🌍 공개 범위에 따른 블록체인활용되는 목적 또는 공개 범위에 따라 다양한 방법으로 블록체인 네트워크를 구성할 수 있다. 퍼블릭 블록체인개방형 블록체인으로 누구나 트랜잭션을 생성할 수 있는 블록체인이다. 통상적으로 블록체인이라는 용어는 퍼블릭 블록체인을 지칭한다. 누구나 참여할 수 있고, 모든 참여자의 상호 검증을 거쳐 신뢰도가 높은 특징이 있다. 하지만 그 만큼 처리해야할 거래기록이 많아지고 이를 공유해야할 노드의 개수가 많아지다 보니 속도가 느린 편이다. 프라이빗 블록체인퍼블릭 블록체인과 다르게 서비스 제공자(기업 또는 기관)의 승인을 받아야만 참여할 수 있다. 엔터프라이즈 블록체인 이라고도 부르며 리눅스재단이 이끌고 있는 오픈소스 블록체인 프로젝트인 하이퍼레저도 이 프라이빗 블록체인으로 분류가 된다. 기업 비지니스를 구현하기에 적합한 환경의 블록체인이고, 속도도 빠르지만 퍼블릭 블록체인과 다르게 상대적으로 중앙화된 특징이 있다. 컨소시엄 블록체인동일한 목적, 가치를 가지고 있는 다수의 기업이 하나의 컨소시엄을 구성하고 그 안에서 작동하도록 만든 블록체인다. 대표적으로 하이퍼레저 패브릭이 있다. 성격은 프라이빗 블록체인과 비슷하지만 일종의 퍼블릭과 프라이빗의 중간 형태로 중앙 관리자에 의해 승인받은 잠여자만이 블록생성을 할수가 있다. 프라이빗 블록체인은 한 기업 혹은 기관이 모든것을 통제하지만 컨소시엄 블록체인은 다수의 기업이 통제를 하기 떄문에 공정성과 확장성을 보완을 하였다. 즉 다수 참여자의 협의가 필요한 분야에서는 컨소시엄 블록체인이 효과적이다. 이를 활용하여 기관 간에 직접 거래함으로써 제3자에 대한 거래 수수료를 줄이고 시간을 단축 한다. 요약 📒 분산원장기술거래 정보를 기록한 원장을 특정 기관의 중앙화된 서버가 아닌 분산화된 네트워크에서 참여자들이 공동으로 기록 및 관리하는 기술을 말한다. 기존의 서비스 은행, 기업들은 중앙집중원장의 형태를 띄고 있다. 블록체인은 중앙집중원장의 단점을 해결하는 목적성을 가졌고 분산원장 기술을 사용한다. 인증과 증명의 효율성, 시스템 안전성 보안 투명성을 큰 장점으로 뽑을수가 있다. 기존 시스템의 경우 여러 중간 매개체 또는 인증기관이 필요했지만 분산원장은 사용자간 거래내역을 직접 공유할 수 있는 시스템이라는 차별성을 가지게 된다. 비용이 줄어들고 정보가 분산되어 있기 떄문에 해킹 및 위조의 위험성도 거의 없다. 💸 트랜잭션블록에 들어가는 거래 기록, 일종의 데이터 사용 기록을 말한다. 블록은 다수의 트랜잭션으로 이루어져 있고, 구조는 헤더와 바디로 이루어져 있다. 헤더에는 메타데이터, 바디에는 트랜잭션들이 구성되어 있다. 블럭은 거래의 기록단위로 다수의 트랜잭션을 포함할 수 있으며, 이때 특정 블록을 기준으로 다음과 같은 점들을 생각해 볼수가 있다. 이 블럭은 체인 중 몇 번쨰 블록인지 이 블럭에는 몇 개의 트랜잭션이 있는지 이 블럭을 누가 생성을 했는지 이 블럭의 크기, 총 전송량 등은 얼마인지 이러한 것들을 메타 데이터 라고 한다. 즉 메타 데이터는 해당 블록이 어떤 블록인지 설명하고, 이러한 정보를 블록에서는 블록 헤더에 저장한다. 일반적인 트랜잭션트랜잭션이란, 데이터베이스의 상태를 변화시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위라고 하며, 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 A.C.I.D를 통해 알수가 있다. 블록체인 트랜잭션블록체인 내에서의 트랜잭션 역시 상호작용 및 작업 수행의 논리적 단위이다. 블록체인 내에서 모든 활동은 트랜잭션을 통해 이루어 지고 블록체인의 상태를 변화시킨다고 말할수 있다.","link":"/2021/12/11/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8_%EC%A2%85%EB%A5%98-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"title":"[Blockchain] 채굴, 노드, 합의 알고리즘","text":"🔨 채굴과 노드채굴채굴(採掘) 또는 마이닝(mining)은 퍼블릭 블록체인에서 상당히 중요한 개념이며, 보상과 사용자에게 참여를 유도시키는 핵심기술중 하나이다. 관리자가 없는 퍼블릭 블록체인에서는 관리자가 없이, 누구든지 인터넷에 연결된 컴퓨터 장비를 이용하여 네트워크에 참여가 가능하다. 이는 운영과 참여의 주체가 불분명하기 떄문에 인센티브 제도인 코인을 발행하여 운영된다. 노드노드(node)는 네트워크에서 연결 포인트 혹은 데이터 전송의 종점, 재분배점 등을 의미한다. 블록체인은 중앙 집중형 서버에 거래 기록을 보관, 관리하지 않고 거래에 참여하는 개개인의 서버들이 모여 네트워크를 유지 및 관리하는데 이 개개인의 서버, 즉 참여자를 노드라고 한다. 노드의 종류풀 노드 (full node)블록체인에서 이뤄진 모든 거래 정보를 전부 저장하는 검증인을 뜻한다. 제네시스 블록 부터 현재 블록까지 모든 블록체인 정보를 수집, 저장한다. 블록체인에서는 주요 데이터를 여러 풀노드가 함께 보관하고 있다. 때문에 해킹을 하기 위해서는 여러 곳을 한꺼번에 공격해야 하므로, 사실상 해킹이 불가능하다고 본다. 풀노드는 블록체인 데이터를 동기화하기 위헤 메모리를 사용한다. 새로운 블록을 추가하기 위해 블록체인의 모든 거래를 검증하고 실시간으로 데이터를 업데이트 한다. 또한 블록체인 분산원장 중 블록체인 거래를 다른 노드로 전송 및 수신하고 확인하는 중요한 역할을 담당하고 있다.즉, 전체적으로 거래내역에 오류가 없음을 확인하고 새로운 블록이 생성될 때 최종 승인하는 역할을 한다. 더 자세한 풀노드의 역할은 다음과 같다. 거래가 진행될 때 각 거래자들의 계좌정보, 잔액 등의 정보확인을 통해 유요한 거래인지 확인한다. 전체 기록을 다 가지고 있기에, 새로운 블록이 추가될 때 조작이 없는지 이전 거래와 내역이 일치하는지 등을 누구의 도움없이 모든 거래에 대한 검증이 가능하다. 새로운 블록이 생성된 후 채굴을 성공한 채굴자에게 올바르게 보상이 제공되었는지 확인하다. 블록에서 이중 지불이 발생하지 않았는지 확인한다. 본인이 가진 기록정보를 다른 노드들에게 전달하는 일을한다. 풀노드는 자신의 PC에 모든 블록체인의 내용을 가지고 있기 때문에 다른 노드의 도움없이 스스로 거래 검증이 가능하다. 하지만 용량이 너무 커서 다운로드를 받는데 시간이 오래 걸리고 하드디스크의 용량을 많이 차지한다는 단점이 있다. 이런 풀노드의 단점을 해결하기 위해 나온 것이 라이트노드(light node)이다. 라이트노드는 가볍고 풀노드와 다르게 자료의 일부분만을 다운받는다. 대신 거래를 위해 내용 검증이 필요한데, 그때마다 풀노드에게 자료를 요청해야만 한다. 라이트 노드(light node)블록체인에 참여하여 거래를 수행하는 노드로, 풀노드에 거래 데이터를 요청하여 개별 거래를 검증하는 기능을 수행한다. 풀노드처럼 모든 블록 정보의 원본을 가지고 있지는 않고 일종의 요약본, 즉 블록헤더에 있는 중요한 데이터만 보유하고 있다. 라이트노드는 모든 블록정보를 가지고 있지 않기 때문에 어떤 새로운 거래 정보를 수신받았을 경우 이 거래가 정상적인지 검증할 수 없다. 반대로 풀노드의 경우 모든 데이터를 가지고 있기 때문에 로컬에 있는 블록 정보를 조회하여 검증을 할 수 있다. 따라서 라이트노드는 개별 거래에 대한 트랜잭션을 확인하기 위한 SPV(Simple Payment Verify, 단순 지불 검증)를 사용한다. SPV는 라이트노드에서 거래를 검증하기 위해 풀노드에게 블록정보를 요청하여 머클트리를 통해 이 거래가 검증된 거래인지를 확인하는 방법이다. 🤝 합의 알고리즘합의 알고리즘(consensus algorithm)이란 다수의 참여자들이 통일된 의사결정을 하기 위해 사용하는 알고리즘을 말한다. 합의 모델, 합의 방식, 합의 메커니즘 또는 합의 프로토콜이라고도 한다. 블록체인 시스템의 경우 네트워크에 참여하는 모든 참여자들이 동일한 데이터를 복사하여 분산 저장하기 떄문에 원본과 사본의 구별이 없으며, 통일된 의사결정을 내릴 수 있는 권위 있는 중앙이 존재하지 않는다. 이런 상황에서 합리적이고 효율적인 의사결정을 내릴수 있는 다양한 알고리즘이 개발되었다. 작업증명(PoW)작업증명(PoW, Proof of Work)이란 목표값 이하의 해시를 찾는 과정을 무수히 반복함으로써 해당 작업에 참여했음을 증명하는 방식의 알고리즘이다. 채굴을 통해 작업증명을 한다. 작업이란 채굴에 이르기까지 연산 과정을 뜻한다. 채굴자들은 컴퓨터로 복잡한 수식을 풀어 조건에 맞는 해시값을 찾는 과정을 반복한다. 이 경우 모든 노드들이 찾아낸 해시값을 검증하고 승인하는 과정을 거쳐 블록에 거래 내역을 저장한다. 따라서 모든 노드들의 승인을 거쳐야 하기 때문에 거래 내역을 속이기가 힘들다는 장점이 있다. 이런 점에서 작업증명 합의 알고리즘은 블록체인이 가지는 탈중앙화라는 본질을 가장 잘 살린 합의 방식이다. 그러나 이런 과정 때문에 거래 처리 속도가 늦어진다는 한계가 있다. 또한 채굴에 필요한 에너지 소비가 심하다는 것도 단점이다. 이 때문에 일정 조건에 따라 블록 생성에 참여하는 노드들을 제한하는 지분증명방식이 등장했다 지분증명(PoS)지분증명(PoS, Proof of Stake)은 해당 암호화폐를 보유하고 있는 지분율에 비례하여 의사결정 권한을 주는 방식이다. 주주총회에서 주식 지분율에 비례하여 의사결정 권한을 가지는 것과 유사하다. 채굴 과정이 필요 없다. 지분증명은 의사 결정 권한을 코인 보유량에 비례해 지급하는 방식이기 때문에 코인을 많이 보유하고 있는 노드일수록 블록 생성에 참여할 수 있는 기회가 더 많다. 블록 생성에 따른 보상도 코인 보유량에 비례한다. 지분증명 방식은 모든 노드들의 승인을 거치지 않아도 되니 작업증명 방식보다 거래 처리 속도가 빠르다. 이는 곧 전력소비를 줄일 수 있음을 의미한다. 이 때문에 이더리움 재단은 기존 합의 방식인 작업증명 방식을 지분증명 방식으로 전환하기 위한 캐스퍼(Casper) 프로젝트를 진행 중에 있다. 그러나 지분증명 방식은 평등을 추구하는 블록체인의 본질에서 벗어나 부익부 빈익빈을 초래하단다는 꼬리표가 따라다닌다. 많은 코인을 가지고 있을수록 더 많은 보상을 받는 구조이기 때문이다. 위임지분증명(DPoS)위임지분증명(DPoS, Delegated Proof of Stake)은 암호화폐 소유자들이 각자의 지분율에 비례하여 투표권을 행사하여 자신의 대표자를 선정하고, 이 대표자들끼리 합의하여 의사결정을 내리는 방식이다. 국민의 대표로 의원을 뽑아 의회를 구성하는 대의 민주주의 제도와 유사하다. 위임지분증명은 노드들이 코인 보유량에 따라 투표권을 행사해 중요한 의사결정 권한을 수행할 일종의 대리인을 산출하는 합의 방식이다. 이는 코인 보유자들이 자신의 권한을 위임해 대표자를 선출하는 방식이 대의 민주주의와 유사해 ‘토큰 민주주의’라는 별명이 붙기도 했다. 위임지분증명 방식의 경우 소수의 대표 노드들에게만 거래 내역 승인을 거치면 되니 처리 속도는 훨씬 빨라진다. 이더리움은 평균적으로 초당 20TPS를 처리하는 반면 이오스는 3000TPS를 처리할 수 있어 속도 면에서의 장점은 이미 검증되었다. 그러나 2018년 9월, 이오스 블록 생성을 담당하는 대표 노드 가운데 일부가 블록생성자가 자격을 유지하기 위해 서로에게 투표했다는 의혹이 제기되었다. 이에 따라 위임지분증명 방식에 치명적인 결함이 있다는 사실이 알려졌다. 이처럼 위임지분증명 방식은 일반 노드들의 투표율이 저조할 경우 소수의 대표 노드들에 의해 블록체인 생태계가 좌지우지 될 수 있다는 한계가 있다. 역사증명(PoH)역사증명(PoH, Proof of History)은 노드 간 합의에 걸리는 시간을 단축한 알고리즘이다. 역사증명 합의 알고리즘은 솔라나(Solana)의 대표적인 기술로 블록체인 네트워크상에서 노드들이 거래가 언제 발생했는지 함께 증명하고 합의함으로써 거래내역을 저장한다. 솔라나는 이 과정에서 검증가능지연함수(VDF, Verifiable Delay Function)를 도입해서 합의를 단순화한다. 또한, 거래내역을 암호화할 때 시간 순서에 대한 정보를 추가함으로써 검증자들이 각각의 거래를 일일이 확인하지 않고도 합의할 수 있다. 합의에 걸리는 시간이 단축되기에 거래 처리 속도는 빨라지며, 속도가 빨라지기에 확장성도 늘어나고 블록체인의 성능 자체가 향상된다. 경과시간이 블록 자체에 임베드되고 검증인들이 역사증명 검증을 병렬화를 통해 역사증명 초기 버전보다 최소 천 배 빠르게 할 수 있기 때문에, 새 노드는 대역 외 정보없이 해당 체인의 정합성을 창조시부터 현재 시점까지 검증할 수 있다. 시빌공격시빌공격(Sybil Attack)이란 한 개인이 다수의 계정이나 노드, 컴퓨터를 구성해 네트워크를 장악하려는 온라인 시스템 보안 위협 중 하나이다. 시빌공격은 한 개인이 여러 개의 소셜 미디어 계정을 만드는 것처럼 간단할 수 있다. 하지만 암호 화폐의 세계에서는 한 개인이 블록체인 네트워크상에서 다수의 노드를 운영하는 것이라 보는 것이 더 적합하다. 시빌이라는 명칭은 다중 인격 장애라고도 불리는 해리성 정체 장애(Dissociative Identity Disorder)를 겪었던 시빌 도르셋(Sybil Dorestt)이라는 여성에 대한 사례 연구에서 유래되었다. 블록체인 기술과 시빌 공격은 서로 큰 관련성이 있다. 비트코인 시스템에서 두 네트워크의 블록체인이 서로 다르다면 더 컴퓨터 파워가 강한 네트워크의 블록체인이 올바른 블록체인으로 인정받는다. 컴퓨터 파워를 기준으로 증명을 수행하겠다고 세계가 합의(Consensus)를 한 것이다. 구체적으로 비트코인에서는 채굴에 참여하는 컴퓨터들이 각각 해시(Hash)를 수행하도록 하는 작업증명(Proof of Work) 알고리즘에 의해 이러한 과정이 수행된다. 만약 증명의 기분이 아이피(IP)의 개수라면 시빌 공격의 대상이 되기 쉽다. 아이피의 경우 논리 주소(Logic Address)이므로 통신 패킷의 조작을 통해 충분히 통신 노드의 숫자를 늘릴 수 있다. 해커는 혼자서 여러 개의 아이피 주소를 이용해 자신이 가진 장부와 올바른 장부라고 거짓말 할 수 있기 때문에 블록체인이 아이피 주소의 개수로 증명된다면, 아이피를 가진 노드의 숫자를 무한정 늘려 증명하는 무한 생성 공격이 가능할 것이다. 이처럼 공격자가 많은 수의 가짜 신원(혹은 시빌 신원)을 생성할 경우, 기존의 신뢰할 수 있는 노드를 네트워크에서 제외할 있다. 이후 블록을 수신하거나 전송하는 것을 거부할 수 있고, 다른 사용자들을 네트워크에서 차단할 있다. 공격자가 네트워크 컴퓨팅 파워나 해시 레이트의 대다수를 통제하는 대규모 시빌 공격일 경우, 51% 공격을 수행할 수 있다. 이런 경우, 주문 중인 거래를 변경하고, 트랜잭션의 승인 거부가 가능하다. 또한, 통제하는 동안 발생한 트랜잭션을 번복하여 이중 지급을 발생시킬 수도 있다. 👛 암호화폐 지갑암호화폐 지갑(cryptocurrency wallet)이란 비트코인, 이더리움 등의 암호화폐를 보관할 수 있는 계정을 말한다. 간략히 지갑 또는 월렛이라고 한다. 지갑은 지갑 주소와 암호로 구성되어 있다. 지갑의 주소는 다른 사람들이 암호화폐를 송금할 수 있도록 공개해도 되지만, 개인 암호는 오직 지갑 소유자 본인만 알고 있어야 한다. 암호화폐 지갑은 비트코인 지갑, 이더리움 지갑 등 각각의 암호화폐 종류별로 따로 가지고 있어야 한다. 비트코인(bitcoin) 지갑은 영문자 대문자, 소문자, 아라비아 숫자의 조합으로 이루어져 있다. 이더리움(ethereum) 지갑은 영문자 소문자와 아라비아 숫자의 조합으로 이루어져 있다. 리플(ripple) 지갑의 경우 지갑 주소와 별도로 데스티네이션 태그(Destination Tag)가 있어야 다른 사람이 송금한 돈을 받을 수 있다. 종류코인지갑은 크게 ‘콜드월렛과’ ‘핫월렛’으로 나뉜다. 코인월렛을 나누는 기준은 인터넷 연결 유무인데, 핫월렛 또는 온라인 지갑은 인터넷 주소가 네트워크에 연결되어 있어 온라인 상태에서만 거래를 주고 받을 수 있으며 실시간으로 거래 정보를 주고받다 보니 Hot하다고 표현한다. 반면 콜드웰렛은 온라인에 연결되어 있지 않고, 오프라인 상태에 있기 때문에 거래가 아예 안 되어 오프라인 지갑, 하드웨어 지갑이라고 부른다. 각각 장단점이 있는데, 핫웰렛은 인터넷을 통해 실시간으로 편리하게 이용 가능하지만, 개인키를 온라인에 연결해서 입력하기 때문에 해킹 등 보안 문제에 취약하다. 반면 콜드월렛은 인터넷이 차단된 하드웨어 장치에 암호화폐를 보관하고, 개인키를 오프라인에서 처리해서 보내기 때문에 보안 측면에서 더 안전하나 실시간 거래가 불가능해 불편하다. 💸 UTXO, 어카운트비트코인과 이더리움의 가장 큰 차이는 기술 활용도에 있다. 비트코인이 디지털 금과 같다면, 이더리움은 디지털 석유와 같은 개념이다. 비트코인의 블록체인은 결제나 송금 같은 단순한 거래에 활용하기 위해 고안됐지만, 이더리움은 거래에서 나아가 일종의 컨트랙트이 가능하도록 개발되었다. 쉽게 말해 비트코인은 코인을 담는 지갑 주소만 있는데, 이더리움은 지갑 주소와 함께 앱을 담는 컨트랙트서 주소도 있다고 볼 수 있다. 또한 블록체인 기술은 많은 제품에 들어가며, 더 많은 사용 사례가 발견될수록 가치가 상승하지만, 적어도 비트코인 블록체인 기술은 비트코인만을 추적하고 있다. 비트코인은 최초이자 가장 신뢰받는 암호화폐라는 장점을 내세워 결제 수단으로서의 영역을 넓히고 있다면, 이더리움은 목표대로 블록체인 생태계를 확장해 가고 있다. 비트코인 - UTXO비트코인은 계정 기반으로 설계되어 있지 않기 때문에 사용자는 비트코인 주소만 가지고 있고, 사용자에 대한 어떤 정보도 블록체인에 저장되지 않는다. 비트코인 지갑에서 보여주는 잔액은 사용자가 사용할 수 있는 덩어리들을 모두 합하여 보여 주는 것일 뿐, 실제의 비트코인은 사용자와 관계없이 덩어리로 존재한다. UTXO의 장단점[장점] 이중 지불 방지 트랜잭션을 발생시키면 해당 UTXO는 검증을 받은 후 TX Pool에 들어간다. 그러므로 이중지불이 발생하면 채굴자들은 Pool에서 UTXO 검사 후 사용 기록이 있다면 해당 거래를 무효화 할 수 있다. 잔고의 증명 UTXO는 돈들이 살아 움직이며 추적하기가 용이한 장점이 있다. 따라서 거래에 대한 유효성을 검증하기가 매우 쉽다. 일반적으로 이더리움 같은 경우는 트랜잭션들을 모두 검증 및 확인하여 최종적으로 잔고를 유추하지만 UTXO는 해당 사용자의 UTXO만 확인하면 되기 때문에 그럴 필요가 없다. 이더리움처럼 어느 계좌에 귀속이 된 기록이 아니라 흩어져 있는 UTXO의 객체들로 특정 소유자의 계좌를 유추하는 것이다. 그래서 특정 계좌의 잔고를 알기가 힘들 수 있지만, 수많은 애플리케이션들이 이러한 기능들을 모두 제공하고 있어서(특정 사용자의 UTXO를 모아주는 기능)잔고를 확인하는 데 큰 불편함이 없다. [단점] UTXO의 가장 큰 단점은 UTXO가 너무 과하게 생성이 될 경우이다. 이더리움은 결과적으로 잔고 하나만 점검하면 끝이지만, UTXO 방식을 채용하는 코인들은 흩어져 있는 UTXO를 모두 모아야 되며 소액 결제를 엄청 자주 하거나, 채굴로 이자를 받게 되면 과도한 UTXO로 인해서 불필요한 수수료를 내야 하는 단점이 생긴다. 이더리움 - 계정이더리움은 계정 기반으로 설계되어 있고, 이더리움의 계정(Account)에는 2가지 종류가 있다. 외부 소유 계정(EOA, External owned Account)라고 불리는 것과 컨트랙트계정(CA, Contract Account)라고 불리는 계정이다. 이름에서도 유추가 가능하 듯 외부소유계정은 누군가가 소유하고 있는, 지갑과 같은 계정이다. 두 가지 계정 중 외부소유 계정이 상위 계정이고 새로 생성되는 트랜잭션은 모두 이 외부소유계정에서 시작하게 된다. 외부소유계정에서 컨트랙트과 관련된 트랜잭션을 만들면 컨트랙트계정에서 받아서 처리하게 된다. 이더리움은 계정과 관련된 정보들을 블록체인에 저장한다. 실제 해당 계정이 얼만큼 이더를 가지고 있는지도 저장된다. 누군가에게 이체 거래를 할 때에, 비트코인에서처럼 덩어리를 쪼개서 보내는 것이 아니라, 이더리움 계정 안에 있는 잔액 상태를 직접 변경하며 보내게 되는 것이다. 계정의 장단점[장점] 공간 절약 UTXO 모델에서 300바이트를 사용할 때 계정 모델은 30바이트만 사용한다. 현실적으로는 이렇게 큰 차이가 나진 않는데, 계정 역시 파트리샤 트리에 저장되기 때문이다. 또한 트랜잭션 역시 더 작은데 이는 각각의 트랜잭션이 오직 하나의 리퍼런스와 시그너처를 필요로 하기 때문이다. [단점] 이중지불 이중 지불 공격에 노출 가능하다는 점이다. 이를 보완하기 위해서 이더리움에서는 모든 계정은 공개적으로 볼 수 있는 논스를 가지고 있고, 계정에서 트랜잭션이 발생할때 마다 하나씩 증가하면서 동일한 트랜잭션이 두번이상 제출되는 것을 방지 하는것으로 이 문제를 해결하고 있다. 차이점 비교어떤 것이 더 훌륭하다라는 것은 이 둘의 기능과 역할에 따라 달라진다. 화폐로서의 역할에 충실해야 한다면 비트코인의 UTXO가 보안성, 익명성이 더 뛰어나니 비트코인이 더 훌륭하다라고 할 수 있다. 만약 DApp과 같이 다양한 기능을 구현하고 싶다면 스마트 컨트랙트를 활용할 수 있는 이더리움의 계정이 더 적합할 것이다.","link":"/2021/12/12/%EC%B1%84%EA%B5%B4-%EB%85%B8%EB%93%9C-%ED%95%A9%EC%9D%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"[Blockchain] 거버넌스","text":"🏘 거버넌스를 통한 플랫폼의 발전거버넌스거버넌스(governance)란 공동체를 이루는 구성원들이 의사결정에 참여하여 중요한 사항을 집단으로 결정하는 체계를 말한다. 협치(協治) 라고도 한다. 쉽게 정의하자면 의사결정이 이루어지는 과정(the process by which decision are made)이라 할 수 있다. 기존의 거버넌스는 정부나 기업처럼 중앙집권적 위계조직에서 상명하복 방식으로 이루어져 왔으나, 소프트웨어 개발자 커뮤니티에서는 각 구성원이 평등한 주체로 참여해 토론과 협의를 통해 집단적 의사결정을 내리는 경우가 많다. 특히, 블록체인 기술의 등장으로, 탈중앙화 분산형 자율조직인 다오(DAO) 들이 생겨나며, 수평적이고 자율적인 거버넌스 구조가 확산되고 있다. 필요성 및 중요성기존의 네트워크와 달리 블록체인 네트워크는 통제 없이 모든 사람이 연결할 수 있고 동시에 분산화된 형태로 독립적으로 존재할 수 있다. 따라서, 블록체인을 통해 기존 네트워크와는 달리 누군가의 개입 없이 사용자들의 이익을 대변한 네트워크 구조를 만들어 낼 수 있다. 블록체인 네트워크는 현실과 마찬가지로 하나의 세계이다. 따라서,세계를 유지하기 위해서는 구성원들과의 이해관계 조정이 필요한데, 사용자들의 이익을 직접 대변할 수 있는 네트워크 구조를 만들기 위해서는 네트워크 구성원 간 의사 통합이 중요해지고, 복잡해질 것이다. 이때 필요한 것이 바로 ‘거버넌스’ 이며, 블록체인 안에서의 거버넌스를 ‘블록체인 거버넌스’라고 부른다. 블록체인 거버넌스는 일반적으로 ‘투표’의 형태로 진행이 된다. 가장 대표적인 블록체인인 비트코인, 이더리움 BIP, EIP 및 개발자 그리고 여러 커뮤니티를 통해 네트워크의 방향성을 정하고 있고, 비트코인 이더리움 이외에도 다양한 코인들이 조금씩 다른 방식으로 네트워크를 거버넌스 하고 있다. 종류온체인 거버넌스온체인 거버넌스(On-Chain Governance) 는 거버넌스가 블록체인 내에서 이루어진다. 온체인 거버넌스는 개발자들, 사용자들, 마이너들이 모두 골고루 참여하여 주로 투표 때문에 정책, 정책수정이 이루어진다. 온체인 거버넌스는 다양한 사용자들이 거버넌스 과정에 지속해서 참여할 수 있는 환경을 구성한다는 점에서 참여자의 공동체적 협력을 높인다는 장점이 있으나 한번 결정이 이루어지면 이후 변경이 어렵다. 이는 블록체인의 핵심인 ‘비가역성’에 입각해 한번 네트워크에 반영된 사항은 쉽게 수정 및 변경할 수 없다는 점에서 타당하기도 하지만 오히려 이러한 점을 악용하여 해커들의 공격 대상이 되기도 한다. 코드에 일부 결함이 존재하는 것으로 밝혀져도 바로 신속한 수정이 이루어질 수 없기 때문이다. 오히려 네트워크의 취약점이 표면에 드러나 일정 수준 이상의 보안성을 유지하기 힘든 구조이다. 크로스 체인 프로젝트들에선 여러 개의 거버넌스가 동시에 실행될 수 있다. 예를 들어 Cosmos란 프로젝트에서 그렇다. 악성 변화들은 피할 수 없음으로 롤백 절차가 반드시 가능해야 한다. 블록체인의 자신의 토큰 은 좋은 행동을 격려하기에 유용한 성과보수나 완벽한 해결책은 아니다. 특히 트레이트 숄팅과 같은 상황에선 토큰 자체의 성과보수로서의 지위가 격하될 수 있다. 액체 민주주의 같은 경우 투표권의 집중화를 완화할 수 있지만, 여전히 대중영합주의 현상을 완전히 차단할 순 없다. 거버넌스는 본질에서 변화에 유용하게 대처하는 메커니즘의 수립이기 때문에 다음과 같은 사항들이 중요하다. 수정 제안 절차가 너무 비용이 많이 들거나 비싸면 안된다. 하지만 수정 제안 절차 비용이 낮으면 낮을수록 스팸 혹은 악성적인 수정 제안이 유행할 수 있다. 수정 제안을 하는 실체들의 정체성을 검증하는 작업도 너무 복잡해서는 안된다. 블록체인이 거래상대방 위험으로부터 자유롭기 위해서 처음부터 설계되었음을 기억해야한다. 하드 포크와 소프트 포크는 실행될 수 있으나 최대한 피해야만 한다. 포크가 잦을수록 네트워크 안전성이 낮아지기 때문이다. 제안들을 범주화 한 다음에 제안들마다 누가 더 많은 투표권을 가질지를 결정할 수 있다. 예를 들어 기술현안 들에 대해선 기술자들이 더 많이 투표권을 행사하도록 조정함으로서 현안과 관계가 크게 없는 입장들이 비합리적 결정을 유행시키는 것을 차단할 수 있다. 오프체인 거버넌스오프체인 거버넌스(off-chain governance)는 체인 위에 명시적인 거버넌스 절차 대신 프로토콜 업데이트 등 중요한 결정사항이 있을 때 그것을 지지하는 참여자들이 포크(체인 분리)하는 것을 말한다. 탈중앙화된 프로토콜의 경우, 관리자 권한을 가진 중앙 관리 주체가 없기 때문에 모든 참여자에게 공평하고 지속가능한 거버넌스를 만드는 것이 항상 이슈가 되어왔다. 오프체인 거버넌스에서는 거버넌스가 블록체인 밖에 있는 온라인 포럼 등을 통해서 이뤄진다. 개발자들은 포럼을 통해서 수정 제안들과 해당 여론을 체크하고 이를 블록체인 내에 정책 변경에 반영한다. 비트코인은 레딧(Reddit)을 통해서 주로 포럼들을 운영하는데 이더리움 같은 경우엔 수정 제안들을 유튜브에 강의 식으로 공개하여 여론을 취합한다. 개발자들이 중심이 되어서 불필요한 투표과정 없이 매우 효율적으로 정책을 빠르게 업데이트할 수 있다. 또한 개발자들이 주로 마이너들의 입장을 반영하므로 마이너들이 커뮤니티를 잘 떠나지 않는다. 이더리움의 창시자 부테린은 오프체인 거버넌스를 반대한다. 왜냐하면 이더리움 온체인 거버넌스가 마이너에서 거버넌스 참여를 박탈하는 결과를 만들기 때문이다. 그 이유는 오프체인 거버넌스에서는 하드 포크의 경우에 마이너는 하드 포크를 설치할지 말지를 결정할 수 있다. 하지만 온체인 거버넌스에서는 다수의 결정에 따라 업데이트가 자동 진행되므로 마이너의 거버넌스 참여권이 심각하게 손상된다. 결국 마이너는 온체인 거버넌스에 남아있을 인센티브를 상실한다. 오프체인은 사용자 입장에서 완전히 신뢰할 수 없다 블록체인 메인 네트워크 운영사나 서버 내부에서 관리 및 운영이 이뤄지다 보니 어떠한 일이 벌어지는지 투명하게 알 수 없고 검증이 불가능하다. 그렇기 때문에 사용자 입장에서 완전히 신뢰할 수 없는 단점을 지닌다. 비록 거버넌스가 향상될지라도 초반에 개발자들이 가진 토큰의 가치가 올라가는 것 외에 개발자에게 돌아가는 보상이 거의 없다. 그래서 개발자들은 점점 다른 프로젝트를 위해 개발진을 떠나는 일이 발생한다. 결국 소수의 개발진 만이 남아서 네트워크 전체를 관리하는 사태가 생기고 별다른 인센티브가 없는 개발자들은 끊임없이 토큰을 비싼 값에 팔고 떠나려는 사용자들에 의한 뇌물유혹에 시달린다. 기능개선 제안BIPBIP(Bitcoin Improvement Proposals)란 비트코인을 개선하고자 제안하는 개선안 수정 및 개선이 필요한 비트코인의 사항에 대하여 문제를 제기하고 해당 쟁점이 타인들로부터 일정한 규모 이상의 지지를 얻게 되면 공식적인 절차를 통하여 BIP 프로세스에 회부되는 것이다. 이후 공식 BIP 에디터가 해당 사항에 대한 심사를 진행해서 필요사항으로 인정이 되면 공식 제안으로 발의될 수 있다. 공식 제안으로 인정되는 경우, 투표 등의 각종 의사결정 방법에 따라 실제 네트워크의 반영 여부를 결정한다. 최근 가장 인기있는 BIP는 BIP141이다. 세그윗은 구현에 따라 거래 속도가 빨라지고 수수료가 줄어든다. 대부분의 BIP는 비트코인의 네트워크를 개선하고 비트코인이 암호화폐의 선두주자이기 때문에 많은 발전에 영향을 준다. EIPEIP(Ethereum Improvement Proposal)는 이더리움 개선 제안을 의미한다. EIP는 이더리움 커뮤니티에 정보를 제공하거나 이더리움 또는 그 프로세스 또는 환경에 대한 새로운 기능을 설명하는 설계 문서이다. EIP는 특징에 대한 간략한 기술 명세서와 특징에 대한 근거를 제공해야 한다. EIP 작성자는 지역사회 내에서 합의를 도출하고 반대 의견을 문서화할 책임이 있다. 이더리움 구현자에게 EIP는 구현 진행 상황을 추적하는 편리한 방법이다. 이상적으로는 각 구현 관리자가 구현 한 EIP를 나열한다. 이는 최종 사용자에게 주어진 구현 또는 라이브러리의 현재 상태를 알 수있는 편리한 방법을 제공한다. ERCERC(Ethereum Request for Comment)는 이더리움 논평 요청서라는 의미이다. 이는 이더리움상의 프로그래밍 표준을 개괄적으로 설명하는 기술 문서입니다. 비트코인 개선 제안서(BIP)처럼 프로토콜 개선을 제안하는 이더리움 개선 제안서(EIP, Ethereum Improvement Proposals)와 이를 혼동해서는 안 됩니다. ERC는 애플리케이션과 콘트랙트가 보다 쉽게 상호작용하는 규약을 만드는 것을 목표로 합니다. 쉽게 말하면 “새로운 아이디어를 내가 제시했으니까 어떤지 평가 해주세요” 라는 글을 작성해서 올린 후에 많은 사람들이 그 의견에 동의한다면 인터넷 표준이 되는 것을 RFC(Request for Comments)라고 한다. ERC는 “이더리움 RFC”로서, 인터넷이 아닌 이더리움의 표준이 될 만한 내용들이라는 것이다.","link":"/2021/12/14/%EA%B1%B0%EB%B2%84%EB%84%8C%EC%8A%A4/"},{"title":"[Blockchain] 블록체인 트릴레마","text":"🔺 트릴레마트릴레마(Trilemma)는 3가지의 문제들이 서로 해결할 수 없는 상황을 만드는, 3중고 또는 세 가지 딜레마를 뜻한다. 개요그리스어 숫자 3을 의미하는 ‘Tri’와 명제를 의미하는 단어 ‘Lemma’가 합쳐져 만들어진 단어이다. 세 가지 각각의 문제가 서로 영향을 주어 어떤 선택을 해도 남은 두 가지 혹은 한 가지의 문제를 악화시키는 결과를 초래할 때 이를 트릴레마라 한다. 고대 그리스 시대부터 이러한 현상에 대해 많은 철학자들이 언급해왔지만 학술적 용어로 문헌에 처음 등장한 것은 영국의 성직자 필립 헨리(Philip Henry)에 의해서였다. 이후에 트릴레마는 각 분야에 공통적으로 나타나는 세 가지 문제의 충돌 현상을 설명하는 용어로 자리매김하게 되었다. 블록체인 트릴레마블록체인에서 트릴레마란 확장성(Scalability), 탈중앙화(Decentralization), 보안성(Security)의 세 가지 문제는 한번에 해결할 수 없음을 뜻한다. 탈중앙화와 안정성에 초점을 맞춘 비트코인과 이더리움 같은 경우, 사용자 수가 아주 많은 지금에 와서는 트랜잭션 처리 속도가 매우 느려서 문제가 되고 있다. 아이러니한 점은 블록체인이 확장성 문제를 해결하는 데 있어서 가장 큰 두 가지 걸림돌이 바로 탈중앙화와 안정성이라는 것이다. 때문에 이러한 세 개념을 묶어 블록체인의 트릴레마라고 부르게 되었다. 호주중앙은행(RBA, Reserve Bank of Australia)은 확장성 트릴레마를 언급하며 “암호화폐는 항상 일부 특징이 부족할 것” 이라며 “이러한 점 때문에 암호화폐가 덜 매력적인 자산” 이라고 밝혔다 확장성(scalability) : 사용자 수의 증대에 유연하게 대응할 수 있는 정도이다. 블록체인에서는 사용자수의 증가에 따라 거래건수가 늘어나더라도 무리 없이 전송 처리용량을 증대시킬 수 있는 능력을 의미한다. 탈중앙화(decentralization) : 중앙집중화를 벗어나 분산된 소규모 단위로 자율적으로 운영되는 것을 말한다. 블록체인은 기존의 서버-클라이언트 관계가 아니라, 개별 노드들의 자발적이고 자율적인 연결에 의해 피투피(P2P) 방식으로 작동한다. 블록체인 기술이 도입되어 사회적으로 널리 확산됨에 따라 기존의 중앙집중식 조직, 기업, 단체, 기구 등은 탈중앙 분산 구조로 변경되고 있다. 보안(security) : 보안이란 블록체인 내의 데이터나 프로그램을 권한이 없는 이용자가 사용할 수 없도록 하는 것을 의미한다. 트릴레마 해결 과정현재 1세대 암호화폐 비트코인과 2세대 암호화폐 이더리움이 암호화폐 피투피(P2P) 거래에 가장 널리 쓰이고 있지만 사용자로 하여금 해당 블록체인 기술의 한계를 체감하게 하고 있다. 비트코인과 이더리움이 직면한 기술적 한계의 대표적인 예가 네트워크가 확장됨에 따라 초당 거래 처리 속도(TPS, Transaction Per Second)가 느려지는 확장성 문제를 꼽을 수 있다. 이를 해결하기 위한 대안으로 나온 3세대 블록체인 이오스(EOS), 솔라나(Solana), 폴카닷(Polkadot), 카르다노(Cardano), 알고랜드(Algorand) 또한 충분한 해결책이 되지 못하고 각자의 문제점을 가지고 있다. 현재 시중에 나와 있는 암호화폐들은 탈중앙화, 보안성, 확장성의 블록체인 트릴레마를 하나 또는 최대 두 개까지만 해결할 수 있고, 세 가지를 동시에 만족시키는 것은 현재로서는 물리적으로 불가능하다고 봐야 한다. 비트코인높은 탈중앙화와 보안을 갖춘 비트코인도 확장성의 한계로 트릴레마를 극복하지 못했다. 비트코인은 애초부터 탈중앙화와 보안에 초점을 맞추고 개발되었는데, 특히 보안 측면에서는 최고의 암호화폐라고 평가받는다. 실제로 비트코인은 암호화된 기술을 바탕으로 서버 역할을 하는 노드들이 네트워킹 되어 블록체인을 검증하기 때문에 쉽게 위변조가 거의 불가능하다. 하지만 시간이 흐름에 따라 비트코인은 점점 더 많은 사용자들을 확보하게 됐고, 자연스럽게 네트워크가 확장됨에 따라 트랜잭션 속도가 느려지는 확장성 문제가 발생했다. 비트코인의 속도는 7TPS로, 3세대 블록체인이라고 불리는 이오스의 3,000TPS에 비하면 현저히 낮은 수치다. 이에 비트코인 개발자들은 확장성 문제를 해결하기 위해 라이트닝 네트워크(lightning network)와 같은 방법을 활용하여 속도를 높이고자 했지만 섣불리 속도를 높이고자 노드의 수를 줄이거나 노드의 일부만 검증하는 방식을 적용하게 되면 네트워크 전체의 보안이 떨어지기 때문에 이렇다 할 방법을 내지 못하고 있는 상태이다. 비트코인은 보안을 위해 과감히 트랜잭션 속도를 포기했으며 아직까지도 확장성은 비트코인의 최대 단점으로 꼽히고 있다. 이더리움이더리움 또한 확장성 문제에 부딪혔다. 이더리움은 현재 이더리움 플랫폼 위의 디앱상에서 이루어지는 거래를 1초에 20건밖에 처리할 수 없는 속도를 가지고 있다. 이더리움의 창시자인 비탈릭 부테린(Vitalik Buterin)은 확장성 문제의 해결을 추구하는 이더리움 2.0을 발표했다. 이더리움 2.0은 작업증명 방식의 대안으로 등장했으며, 지분증명 방식과 샤딩 기술을 바탕으로 실생활에서 이더리움을 사용 가능한 수준까지 끌어올릴 수 있다. 지분증명 방식을 통해 불필요한 전력과 컴퓨팅파워를 소모해 비용이 많이 발생하는 작업증명 방식의 단점을 해결할 수 있고, 빠른 블록 검증과 합의 또한 가능하다. 지분증명 방식은 해당 암호화폐를 보유하고 있으면, 그 지분에 따라 채굴 가능성이 올라가기 때문에 채굴과정에서 큰 비용이 필요하지 않고 블록체인 네트워크 수수료가 낮아지는 효과를 낼 수 있다. 이더리움 2.0의 또 다른 핵심기술은 샤딩이다. 샤딩은 이더리움의 트랜잭션 처리 속도를 높이기 위한 기술로, 지분증명의 검증자를 소규모 그룹(샤드)로 분리해 각 그룹이 서로 다른 이더리움 트랜잭션을 동시다발적으로 처리하는 방식이다. 비탈릭 부테린은 “이더리움 2.0은 지분증명 방식과 샤딩 등 블록체인 아키텍처를 새롭게 구성한 만큼 실시간으로 거래 처리를 할 수 있다.”고 말했다. 이에 이더리움 2.0으로 블록체인 트릴레마를 해결할 수 있을지에 대한 사람들의 관심이 쏠리고 있다. 이오스3세대 블록체인의 대표격인 이오스는 위임지분증명(DPoS) 합의 알고리즘을 채택하여 탈중앙화와 확장성 문제를 해결하고자 한다. 위임지분증명방식은 전체 코인 보유자들이 21명의 블록 생성자(BP)를 선출한 후 그들에게 블록체인의 운영을 맡긴다. 이는 각 노드가 가진 이오스 코인에 대한 지분을 투표를 통해 대표노드에게 위임함으로써 민주적인 의사결정 시스템을 가진다는 점과 대표노드를 견제할 수 있다는 점에서 탈중앙화를 추구한다고 볼 수 있다. 또한 전체 노드가 아닌, 이렇게 선출된 21개의 노드에서만 거래를 검증하면 더욱 빠른 연산이 가능하다. 전체 네트워크로부터 합의를 도출하는 방식이 아니라, 선출된 21명의 대표노드만 합의 과정에 참여시킴으로써 트랜잭션 속도, 즉 확장성 문제의 해결을 추구한다. 하지만 이오스 역시 블록체인의 트릴레마 문제를 겪고 있다.노드의 개수가 소수라는 것은 블록 생성 시간을 단축하고, 트랜잭션 속도를 높이지만 이는 탈중앙화 가치를 벗어날 수 있다. 소수의 노드만이 블록 생성에 대한 보상인 이오스를 독점한다면, 그리고 이오스가 투표권을 가지고 있는 경우 블록 생성자의 권한은 시간이 지날수록 급격히 성장할 것이다. 따라서 이오스의 확장성이 아무리 좋더라도 탈중앙화에 벗어났다고 볼 수 있다 한편, 보안 또한 문제가 될 수 있는데 비트코인과 이더리움의 경우 다수의 노드를 공격하는 것이 어려워 높은 보안성을 가지고 있다. 하지만 이오스의 경우 소수의 노드가 블록을 생성하기 때문에 노드에 대한 공격이 쉬워져 보안이 떨어진다.","link":"/2021/12/15/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%8A%B8%EB%A6%B4%EB%A0%88%EB%A7%88/"},{"title":"[Blockchain] 블록체인 레이어","text":"🌐 블록체인 레이어지난 몇 십년간 통신수단이 크게 변화해 온 가운데 인터넷은 ‘정보교환혁명’을 일으키어, 우리 삶에 큰 영형을 주었다. 이와 마찬가지로 블록체인은 현제 ‘가치교환혁명’이라 해서 현대사회에서 주목을 받고 있다. 이번에는 이 기술을 깊이 이해하기 위해 레이어 구조로 본 전체상을 다뤄보고자 한다. 레이어 구조레이어(Layer)는 영어로 층을 의미하고, 계층이라고도 말한다. 주로 웹 브라우저나 그래픽 소프트웨어에서 사용되는 기술이며, 통신용어에서는 데이터 전송을 원활하게 하기 위해서 처리의 역할분담으로 층을 나누는 것을 레이어라 부른다. 레이어 구조로 유명한 ‘OSI 참조 모델’은 인터넷 통신 프로토콜이며, 국제표준화기구(ISO)에 의해 책정된 통신계층모델. 통신 구조를 세계 기준으로 통일하고, 통신 문제 등을 해결하였다. 하나에 예시로 현미경으로 투명한 판이 몇 개 겹쳐 있는 상태를 들여다 보고 있는 것을 생각해보겠다. 들여다 보는 본인은 어떤 판을 뽑아내거나, 데이터를 수정한 판을 돌려놓을 수 있다. 이와 같이 각 층이 나누어져 있는 덕분에 하층 데이터를 교환해도 상층 데이터에 영향을 미치지 않는 것이 장점이다. 각 시스템 구조마다 차이가 있지만 개발자나 관리자는 이것을 바탕으로 버그 수정이나 기능 업데이트 등을 진행한다. 5개 영역과 7개 레이어도표로 표현한 층을 위에서 보면 하나에 서비스(앱, 소프트웨어)가 된다. 각 레이어 역할을 블록체인에 적용하면 크게 5가지 영역으로 나누어진다. 각각 네트워크 영역, 블록체인 영역, 확장 영역, 애프리케이션 영역, 서비스 영역이 되어 레이어 수는 OSI참조 모델에 따라 7층으로 나누었다. Layer0블록체인에서 네트워크 구조를 결정하는 가장 하층에 위치하는 부분. 여기를 결정하지 않으면 통신이나 송금, 토큰 발행이 못한다. 블록체인 내에서 생성되는 블록이나 노드 사이의 통신(P2P등)을 행하기 위한 프로토콜이 된다. Layer1.0PoW나 PoS 등의 합의 알고리즘을 규정하는 레이어 블록 생성・승인을 규제하는 프로토콜이며, 정하는 기능에 따라 특징이 크게 좌우된다. 대표적인 PoW은 분산성과 보안 능력은 높지만 확장성 문제나 51% 공격 등의 리스크가 있다. 한편 PoS는 확장성, 51% 공격의 문제는 낮지만 보안 능력과 분산성을 희생시킨다. 이외에도 DPoS, PoI 등 취약점을 보완한 알고리즘이 있고 특징에 따라 어느 기능을 채용할지는 각양각색이다. Layer1.5생성되는 블록 내에 어떤 정보를 놓는지를 결정한다. 이더리움은 스마트 계약에 의한 디지털 계약 내용을 블록 내에 놓거나, 비트코인에서 확장성 문제 해결책인 segwit에 관한 논의는 이 부분이 해당된다. 네트워크와 블록체인 영역인 레이어０와1.0, 1.5의 층은 장단점이 현저하게 나오는 장소이며, 출시함에 있어서 어디를 중시할지는 자주 논의된다. Layer2.0블록체인 상의 통신 규모를 확장하여, 처리능력을 확대한는 레이어. 프로그래밍 언어 등 구성부분을 규정하는 장소이고, 현제 비트코인은 이 영역 기술개발로 접어들었다. 이 부분에서는 비트코인의 처리 능력을 향상하기 위해 라이트닝 네트워크나 사이드체인이 논의되어 있다. Layer2.5가상 머신의 블록체인을 OS단계로 실행하기 위한 기능을 확장한다. 예를 들면 PC의 윈도우나 애플 단말기의 iOS, 구글 크롬 OS 등이 해당되고 앱이나 서비스 기능에서 필수인 부분이다. 확장 영역은 말 그데로 블록체인 처리능력을 확장하기 위한 레이어이며, 사용자가 쓸 때 방법이나 시스템 컴퓨팅을 맡은 자리이기도 한다. Laye3.0가상 머신 상에서 앱이 잘 작동하기 위한 기능을 구현하는 레이어. DEX나 Dapps(분산형 앱)이 이에 해당되고 실제로 사용자가 각 앱을 이용하면서 디팩토 스탠다드 (사실상의 표준)가 된다. 이제까지의 층, 영역을 플랫폼으로 하여, 실생활에서 사용자가 앱을 이용하는 부분이 된다는 것이다. Layer4.0이 영역까지 구현되면 사용자에게 서비스로 일반 재공되는 앱이 완성된다. 암호자산 에서는 각 거래소의 월렛, PC 상에서는 각 브라우저가 이에 해당되고 사용자는 제공된 앱이나 서비스로 부가된 혜택을 얻을 수 있게 된다.","link":"/2021/12/16/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EB%A0%88%EC%9D%B4%EC%96%B4/"},{"title":"[Blockchain] 블록체인 확장성","text":"⚡ 블록체인 확장성블록체인 트릴레마 중에서는 ‘확장성’에 관한 문제가 가장 큰 이슈거리이다. 확장성이란 블록체인이 많은 양의 트랜잭션을 처리할 수 있는 능력이며, 초당 트랜잭션 처리량인 TPS로 수치화할 수 있다. 확장성 문제란 주로 보안성 및 탈중앙화 정도를 훼손하지 않으면서 확장성을 증대시키기 어려움을 의미한다. 레이어를 통한 확장성 구조화를 위해 블록체인을 ‘하드웨어’, ‘네트워크’, ‘블록체인’, ‘오프체인’의 네 계층으로 구분한다. 계층 형태로 구조화된 다른 시스템들처럼, 상위 계층은 하위 계층이 제공하는 서비스를 추상적으로­­(상세한 동작 원리를 알 필요 없이)이용한다. 하드웨어 계층을 제외한 나머지 논리적 계층들은 순서대로 레이어-0, 레이어-1, 레이어-2라는 별칭이 붙어있다. 가령 레이어-2 확장성 솔루션이란 오프체인 계층에 속해 있는 확장성 솔루션을 지칭한다. 하드웨어 계층하드웨어하드웨어(hardware) 계층은 가장 낮은 곳에 위치한 계층이자 다른 상위 계층들이 구동되기 위한 기반이다. 상위의 논리적인 계층들에는 레이어 번호가 할당돼 있지만, 하드웨어 계층은 물리적인 영역이므로 별도의 번호를 가지지 않는다. 신뢰 실행 환경만일 하드웨어적으로 보안을 보장한다면, 즉 데이터와 코드의 무결성 및 기밀성을 보장한다면 신뢰를 제공할 수가 있다. 궁극적으로, 신뢰할 수 있는 하드웨어로 구성된 네트워크에서는 상위 계층 프로토콜들의 효율성이 크게 오를 것이다. 네트워크 계층네트워크는 가장 아래에 위치한 논리적 계층으로, 레이어-0이라고도 부른다. 네트워크 계층은 확장성, 보안, 프라이버시 측면에서 매우 중요한 역할을 담당한다. 효율적인 레이어-0는 높은 트랜잭션 처리량과 회복력을 보장하므로 상위 계층들의 구동을 잘 보조할 수 있다. 공용 네트워크일반적으로 블록체인에서의 네트워크는 노드 간 비동기적으로 정보를 교환하기 위한 공용(public, 공개) P2P 네트워크이다. 사설 네트워크블록체인 스택(stack)에서는 효율을 위해 사설(private) 네트워크를 활용하기도 한다. 블록체인에 트랜잭션을 쓰는 채굴자들은 빠르고 효율적인 채굴을 위해 FIBRE와 같은 전용의 사설 채굴 네트워크를 사용한다 믹스넷믹스넷(Mix network)은 여러 송신자의 메시지를 섞어 무작위 순서로 전송하는 프록시 서버들의 체인을 사용해 통신을 추적하기 어렵게 만든 구조이다. 요청을 보내는 클라이언트와 자원을 공유하는 서버 사이의 연결(link)을 깸으로써 도청자가 종단 간(end-to-end) 통신을 추적하기 어렵게 한다. 프록시 서버란 클라이언트가 서버로부터 자원을 찾는 요청에서 중계자 역할을 수행하는 서버 응용프로그램 또는 장비를 의미한다. 믹스넷을 사용하면 상위 레이어들의 보안성을 근본적으로 향상시킬 수 있다. 믹스넷의 대표적인 응용 및 구현체로는 토르(Tor)가 있다. 블록체인 계층블록체인 계층은 레이어-1이라고도 부른다. 블록은 네트워크 참여자들이 전파한 트랜잭션들의 축적이며, 이들의 체인을 통해 확장만-가능한(append-only) 구조를 형성한다. 각 트랜잭션은 블록체인의 상태(state) 업데이트를 내포한다. 트랜잭션을 통해 디지털 자산을 교환하거나 응용프로그램(스마트 컨트랙트)을 실행할 수 있다. 블록체인의 무결성은 참여자들 간 합의 알고리즘으로부터 보장되는데, 예를 들어 연산에 의존하는 작업 증명 등이 연구되고 있다. 블록체인은 참여 제한 여부에 따라 무허가형(permissionless) 또는 허가형(permissioned)으로 분류된다. 허브 앤 스포크허브 앤 스포크(Hub-and-spoke) 구조는 ‘중심과 바큇살 구조’로 직역할 수 있다. 문자 그대로 중심이 되는 메인 체인(main chain)과 주변의 자식 체인(child chain) 그리고 메인 체인과 자식 체인 간 연결인 바큇살(spoke)로 형성된 시스템을 칭한다. 메인 체인은 시스템의 합의를 책임진다. 자식 체인은 사용자 레벨에서의 트랜잭션을 처리한다. 자식 체인의 트랜잭션들에 대한 요약(블록의 해시 등)은 메인 체인에 주기적으로 등록된다. 허브 앤 스포크 구조에 기반한 블록체인 확장성 솔루션은 매우 많다. 지금은 레이어-1을 살펴보고 있으니, 레이어-1에 해당하는 솔루션을 살펴보자. 사이드체인(Sidechain): 사이드체인은 고유의 합의 알고리즘을 가지는 독립적인 자식 체인이다. 비록 트랜잭션을 분담해 처리할 수 있지만, 메인 체인과 사이드체인들 각각은 아예 별도의 체인이므로 레이어-2 솔루션으로 분류되지 않는다. 사이드체인과 메인 체인의 소통은 릴레이(relay)를 통해 구현된다. 샤딩(Sharding): 다음 용어들은 이더리움 2.0을 기준으로 한다. 샤딩 시스템에서 비콘 체인(beacon chain)은 합의 참여자인 검증자들(validators)을 저장하고 관리하는 메인 체인이다. 샤드 체인(shard chain)은 샤딩된 사용자의 계정 및 트랜잭션을 저장하고 처리하는 자식 체인이다. 샤딩은 비콘 체인과 샤드 체인 간 타당성을 분리해 생각할 수 없는 긴밀한 결합(tight-coupling)성을 요구하므로 레이어-1 솔루션에 해당한다. 기능성 탈출 속도블록체인계에서는 “최대한 단순해야 한다” 혹은 “단순함이 최고다” 등의 철학을 흔히 볼 수 있다. 복잡성은 더 많은 오류 발생 가능성과 공격 취약점을 내포하기 때문에 문제가 된다. 블록체인의 오류를 수정하려면 거버넌스를 통해 네트워크 구성원의 동의를 얻어 약속된 시간에 하드포크해야 한다는 어려움이 존재한다. 또한, 공격당할 시 재정을 비롯한 큰 피해를 야기할 수 있다. 따라서 레이어-1은 안정성과 유지에 초점을 맞추고, 오직 긴급 상황에만 큰 변화를 반영하는 것이 좋다. 가령 양자 컴퓨터의 등장으로부터 기반 프로토콜의 암호학적 요소가 붕괴된다면, 레이어-1을 수정해야 한다. 반면 복잡한 기능은 레이어-2로 구현하는 것이 합리적이다. 더불어 레이어-2는 쉽게 도입 및 철회할 수 있으므로 실험적이고 혁신적인 도전도 가능하다. 이러한 종류의 레이어 분리는 매우 좋은 아이디어이며, 장기적으로는 지향해야 할 방향이다. 그러나 이 아이디어는 중요한 점을 놓치고 있다. 바로 “레이어-1이 충분히 강력해야 원하는 레이어-2 프로토콜을 구동할 수 있다”는 점이다. 레이어-1이 충분한 수준의 역량을 확보한 상황을 기능성 탈출 속도(functionality escape velocity)의 확보라 칭한다. 물리학에서 탈출 속도란 중력장을 빠져나가기 위한 최소한의 속도로 이해할 수 있는데, 마찬가지로 기능성 탈출 속도는 레이어-2를 지원하기 위한 최소한의 기능 및 성능으로 이해할 수 있다. 기능성 탈출 속도를 확보했다면 기반(레이어-1)을 수정하지 않고서 그 위에 원하는 바(레이어-2)를 모두 구현할 수 있다. 반면 기능성 탈출 속도를 확보하지 못한 경우에는 레이어-2 프로토콜을 구동하지 못하거나, 신뢰할 수 있는 제삼자(Trusted Third Party, TTP)에게 의존할 수밖에 없다. TTP의 존재는 참여자 모두가 상호 불신하며 이성적(rational)이라는 레이어-1의 가정을 훼손한다. 기능성 탈출 속도는 다음의 세 요소를 충족함으로써 확보할 수 있다. 프로그래밍 언어(Programming language) 레이어-1은 사용자가 작성한 스크립트(script)를 수행할 수 있어야 한다. 프로그래밍 언어는 단순한 기능만을 갖춰도 되며, 고성능일 필요가 없다. 튜링 완전(Turing completeness)할 필요도 없다. 그러나 적어도 레이어-2에서 요구하는 검증 로직(logic)을 수행할 수 있을 만큼의 연산력은 제공해야 한다. 풍부한 상태 저장성(Rich statefulness): 계좌의 모든 코인을 완전히 해제(free)하지 않고서 상태를 바꿀 수 있는 능력이다. 프로그래밍에서 변수를 선언하고 할당 및 갱신할 수 있는 능력으로 쉽게 이해할 수 있다. 가령 롤업에서 코인은 최신 상태 루트를 추적하는 프로그램에 의해 제어되는데, 최신 상태 루트의 갱신은 코인을 해제하는 것이 아니라 단순히 상태를 변경함으로써 수행된다. 풍부한 상태 저장성 없이는 대부분의 레이어-2 프로토콜을 구현할 수 없다. 데이터 가용성(Data availability): 레이어-2에서의 활동은 어떤 식으로든 블록체인에 기록돼야 하고, 그 합의는 블록체인이 처리할 수 있고 보장할 수 있는 기록된 데이터의 양에 의존한다. 따라서 블록체인은 적정 수준 이상의 데이터 가용성을 보장할 수 있어야 한다. 또한 데이터 대기 시간도 중요한데, 블록 생성 간격이 너무 길면 레이어-2의 지연(latency) 정도 역시 높아진다. 오프체인 계층오프체인 또는 레이어-2 프로토콜은 레이어-1이 적어도 다음 두 속성을 제공할 것임을 가정하고 있다. 무결성: 오직 유효한 트랜잭션만 장부에 추가된다. 가용성: 유효한 트랜잭션은 임계 시간을 초과하기 전, 언젠가는 장부에 추가된다. 레이어-2 프로토콜은 온체인 트랜잭션과는 달리 모든 트랜잭션을 즉각적으로 블록체인에 공시(publish)하지 않는다. 프로토콜의 무결성과 유효성은 부모 체인(parent-chain)의 합의 알고리즘에 전적으로 의존한다. 사이드체인이 고유의 합의 알고리즘을 가지기 때문에 레이어-2 솔루션으로 분류되지 않음을 상기해보자. 레이어-2 프로토콜은 크게 채널과 커밋 체인의 두 방법으로 분류된다. 더불어, 최근에 주목받는 블록체인 확장성 솔루션으로는 레이어-1에 더 많이 의존하는 준(semi) 레이어-2 프로토콜이 있다. 레이어-2 프로토콜과 준 레이어-2 프로토콜 혹은 레이어-2 프로토콜과 레이어-1 프로토콜의 하이브리드(hybrid) 프로토콜도 연구되고 있다. 채널채널(Channel)은 스크립트나 스마트 컨트랙트를 통해 사전 설정된 규칙을 따르는 2명 또는 N명의 동등한 당사자들이 참여하는 P2P 매체이다. 본래 채널은 당사자들 간 빠른 자금 교환을 위해 제안됐다. 이후 임의의 상태를 다루도록 개념이 확장됐다. 당사자 간에 직접적으로 연결된 채널이 없어도, 라우팅(routing)을 통해 여러 채널을 거쳐 상태 전이를 반영할 수 있다. 커밋 체인(허브 앤 스포크)커밋 체인(Commit-chain)은 중앙화됐지만 신뢰할 수 없는 중간자에게 의존하는 레이어-2의 체인이다. 일반적으로 허가형 블록체인의 양상을 띤다. 대표적인 커밋 체인 구현체로는 플라즈마(Plasma)가 있다. 플라즈마는 중앙화된 주체로부터 운영되므로 별도의 합의 알고리즘이 필요치 않다. 만일 운영자가 부적절한 행동을 취하면, 참여자들은 비구금형 특성을 통해 해당 블록체인으로부터 자유로이 탈출(exit)한다. 탈출에 성공한 사용자는 검증된 상태를 가지고 안전하게 상위 체인으로 옮겨간다. 이때 상위 체인이란 레이어-1에 해당하는 메인 체인이 될 수도, 아니면 계층 구조를 가진 다른 플라즈마 체인이 될 수도 있다.","link":"/2021/12/17/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%99%95%EC%9E%A5%EC%84%B1/"},{"title":"[Blockchain] 블록체인 상호운영성","text":"💸 블록체인 상호운영성블록체인 상호운용성(interoperability)은 여러 체인 간 자산의 이동이 가능하도록 하는 속성이다. 보다 일반화하자면 체인 간 임의의 데이터 이동이나, 상대 체인의 이벤트 발생 감지 등이 가능하도록 하는 속성이다. 상호운용성을 갖춘 블록체인은 플랫폼의 제약을 받지 않는다. 가령 비트코인에서는 풍부한 기능을 갖춘 스마트 컨트랙트를 구동할 수 없지만, 만일 상호운용하다면 비트코인에서 이더리움상의 스마트 컨트랙트를 호출할 수가 있다. 이외에도 상호운용성은 다양하게 활용 가능하다. 대표적으로 다음과 같은 용처들이 있다: 자산 이동: 체인 A에서 체인 B로의 자산 이동이 가능하다. 또는 체인 B의 자산에 대한 담보로써 체인 A의 자산을 묶어둘 수 있다. 스마트 컨트랙트의 호출: 스마트 컨트랙트 기능이 없는 체인 A에서 다른 체인 B상의 컨트랙트를 호출할 수 있다. 보안성 위탁: 체인 A의 보안성이 부족한 상황, 가령 작업증명(PoW) 기반 블록체인이지만 네트워크 참여자 수가 적은 경우에, 자산을 엮음으로써 (상대적으로) 안전한 체인 B의 보안성에 의존할 수 있다. 그러나 체인 A의 보안 위협이 체인 B의 자산 가치에 영향을 무조건 주는 것은 아니다. 프로토콜에 따라 줄 수도 있고(가령, 샤딩) 아닐 수도 있다. 확장성 증대: 상호운용이 가능한 여러 체인에서 병렬적으로 트랜잭션을 처리함으로써 블록체인 확장성 증대를 꾀할 수 있다. 상호운용성을 획득하기 위한 기술이 여럿 연구된 바 있는데, 비탈릭 부테린은 2016년 R3 보고서를 통해 블록체인 상호운용성을 세 가지 기술적 관점으로 구분했다. 중앙화된 혹은 멀티시그(multisig) 공증인 스킴: 관계자 또는 관계자 모임의 합의를 통해, 체인 A에서 어떠한 이벤트가 발생했을 때 체인 B에서의 특정 행동이 진행되도록 한다. 사이드체인(Sidechain)/릴레이(Relay): 상대방 블록체인의 이벤트나 상태를 읽고 검증할 수 있는 블록체인의 시스템이다. 해시-락킹(Hash-locking): 해시락이란 특정 데이터(해시의 역상)가 공개되기까지 자금의 사용을 막는 기술이다. 해시락을 이용해 크로스-체인 트레이딩인 아토믹 스왑(atomic swap) 등이 가능하다. 본 글에서는 특히 사이드체인/릴레이를 통한 확장성 증대 측면에 집중하여, 허브 앤 스포크(hub-and-spoke) 구조에서의 상호운용성을 살펴볼 것이다. 사이드체인블록스트림(Blockstream)에서는 사이드체인을 “다른 블록체인으로부터의 데이터를 검증하는 블록체인”으로 정의했다. 그러나 이 정의는 너무 광범위한 점과 다른 체인의 검증을 수행함으로써 이어지는 행동과 목적이 없다는 점이 아쉽게 느껴진다. 일반적으로 사이드체인이라 하면 ‘페깅된(pegged) 사이드체인’을 의미한다. 이는 (주로) 두 체인의 크로스-체인 자산 이동성을 위해 다른 블록체인의 데이터를 읽는 기능성에 해당한다. 페깅을 위해서는 두 체인이 서로가 서로의 사이드체인이 되거나 어떠한 형태로서의 신뢰가 존재해야 한다. 특별한 언급이 없다면 이하 등장하는 사이드체인은 모두 페깅된 사이드체인을 칭한다. “체인 B가 체인 A의 사이드체인이다”라는 말은 얼핏 보면 복종 관계를 암시하는 것 처럼 느껴지지만, 실제로는 그렇지 않다. 사이드체인은 고유의 합의 알고리즘을 가지는 독립적인 체인이므로 체인 A와 체인 B는 평등한 관계에 있다. 다만 데이터의 흐름에 따른 메인 체인(부모 체인, 그림 1에서의 체인 A)과 사이드체인(자식 체인, 그림 1에서의 체인 B)이 존재할 뿐이다. 사이드체인은 메인 체인의 데이터를 읽고 검증할 수 있다. 릴레이공증인 스킴메인 체인에서 사이드체인의 데이터를 다루기 위해서는 어떤 방법을 통해서든 사이드체인을 메인 체인에 온체인 데이터화해야 한다. 가장 쉬운 방법은 공증인이라는 신뢰할 수 있는 중간자를 통하는 것이다. 이 공증인은 체인 B에서 일어난 일을 체인 A에 전달하고 이후 작업을 시작한다. 완체인(Wanchain), 코스모스(Cosmos), 폴카닷(Polkadot) 등 여러 이종 다중체인(heterogeneous multi-chain) 프레임워크에서 공증인 스킴을 채택하고 있다. 그러나 이러한 공증인 스킴은 당연하게도 탈중앙화 정도의 훼손을 야기한다. 릴레이반면 릴레이는 별도의 신뢰 주체 없이 체인 스스로가 다른 체인의 데이터/이벤트를 검증하도록 하는 기술이다. 릴레이를 위해서는 상호작용에 앞서 블록 헤더를 전달해야 한다: 블록 헤더의 전달 (그림2) 사이드체인인 체인 B에는 메인체인인 체인 A의 블록 헤더를 검증할 수 있는 스마트 컨트랙트 C가 있다. 릴레이어(Relayer)가 체인 A의 블록 헤더를 C로 전달한다. C가 체인 A의 블록 헤더의 유효성을 검증해, 유효할 경우 저장한다. 체인 A의 최신 블록에 대해 과정 1~2를 반복한다. 이는 체인 B의 컨트랙트를 통해 체인 A의 읽기-전용(read-only) 라이트 클라이언트를 구동하는 것으로 간주할 수 있다. 혹은 체인 A의 헤더 체인을 구동하는 셈이다. 다음 그림 3을 참고하자. 이제 체인 B에 체인 A에 대한 데이터가 기록되어 있으므로, 본격적으로 상호작용할 수 있다: 트랜잭션의 검증 (그림4) 체인 A상에서 체인 B와 상호작용하기 위한 트랜잭션 T를 발생(가령, 토큰의 잠금)시킨다. 이 트랜잭션이 담긴 블록의 블록 헤더를 H_A라 하자. 상호작용의 주체는 목적 트랜잭션 T가 H_A에 포함되었음을 체인 B상에서 입증하고자 한다. 이를 위해 T와 T의 머클 증명 P_T을 제출한다. 체인 B상의 스마트 컨트랙트를 통해 P_T가 올바름을 검증한다. H_A가 스마트 컨트랙트 C에 포함되어 있고 머클 증명 P_T가 유효하면, 그리고 T가 목적에 맞으면(가령, 토큰의 잠금) 상호작용의 이후 절차(가령, 토큰의 발행)를 수행한다. 즉, 저장된 헤더 체인과 머클 증명을 통한 SPV(Simple Payment Verification)를 스마트 컨트랙트에서 수행하는 셈이다. 이로써 상대 체인에서 발생된 목적 트랜잭션의 존재 혹은 부재를 검증할 수 있다. 브릿지릴레이가 타 블록체인의 읽기와 검증을 수행하는 기술 및 시스템이라면, 브릿지(bridge)는 서로 다른 블록체인 간 상호작용을 수행하는 주체 혹은 시스템이다. 즉, 브릿지가 릴레이 기술을 활용하는 포괄적 개념이다. 사이드체인/릴레이 사례BTCRelayBTCRelay는 이더리움 스마트 컨트랙트에서 비트코인 체인을 읽을 수 있도록 한 구현체이다. 물론, 이러한 종류의 상호운용성은 단방향(one-way)이다. 비트코인의 스크립트 언어는 충분히 복잡한 기능을 담을 수 없기 때문에 이더리움 체인을 읽을 수 없다. PeaceRelayPeaceRelay는 두 이더리움 기반 블록체인을 연결하는 기술이다. 가령 PeaceRelay를 통해 이더리움과 이더리움 클래식을 연결할 수 있다. 양 체인 모두 스마트 컨트랙트의 구동이 가능하므로 양방향 페깅이 가능하다. 워털루(Waterloo)워털루는 이더리움과 이오스 간의 릴레이를 위한 프로젝트이다. 양방향 상호운용을 위해 워털루는 두 릴레이 솔루션을 엮었다, 즉, 이더리움에서 이오스로의 릴레이와, 이오스에서 이더리움으로의 릴레이라는 두 독립적인 솔루션으로 구성된다. 두 솔루션 모두 스마트 컨트랙트를 통해 상대 체인의 헤더 검증을 수행한다. 도지더리움(Dogethereum)도지더리움은 도지코인과 이더리움 간 양방향 페그를 가능하게 했다. 우선 그 구조를 간단하게 생각해보자. 도지(Doge)에서 이더(ETH)로의 이동은 이더리움 스마트 컨트랙트를 사용하면 된다. 그러나 도지코인에는 스마트 컨트랙트가 없으므로, 이더에서 도지로의 이동은 다른 방법을 생각해야 한다. 도지더리움에서는 담보를 활용해 양방향 페그가 가능하게 했다. 우선 도지에서 이더로의 이동을 생각해보자. 사용자가 이더리움상의 도지 토큰을 얻고 싶다면 ‘브릿지 운영자’에게 도지를 보낸다. 브릿지 운영자는 도지를 받으면 잠금 상태로 보유한다. 이후 스마트 컨트랙트가 ERC20 도지 토큰을 발생해 배부한다. 다음은 이더에서 도지로의 이동이다. 사용자가 도지 토큰을 소각한다면, 브릿지 운영자는 상응하는 양의 도지를 사용자에게 돌려주도록 요구받는다. 도지더리움 플랫폼에서는 누구나 브릿지 운영자가 될 수 있다. 브릿지 운영자는 담보(보증금)로써 이더를 스마트 컨트랙트에 묶어두는데, 만일 악의적 행동을 했을 경우 타인의 신고를 통해 보증금을 잃게 된다. 사이드체인/릴레이 향후 연구현재로서 사이드체인/릴레이 기술에는 몇 가지 한계점이 존재한다: 데이터 가용성 문제: 릴레이에는 상대 블록 헤더 정보를 주기적으로 업로드하는 주체인 릴레이어가 존재한다. 데이터 가용성을 온전히 릴레이어에게 의존한다는 점이 보안 취약점으로 작용할 수 있다. 분기(Fork)의 발생: 릴레이한 메인 체인의 블록 헤더가 당장에는 유효할지라도, 분기가 일어나 결과적으로 유효하지 않은 블록이 될 수 있다. 릴레이의 비동기성: 하나 혹은 양 체인 모두 완결(finalize)이 느린 경우, 한 체인이 다른 체인에서 검증되기까지 오랜 시간이 소요된다. 이는 크로스-체인 연산의 속도를 제한한다. 합의 알고리즘의 제한: 메인 체인은 작업증명 기반 블록체인일 필요가 있다. 지분증명(PoS) 등 다른 종류의 합의 알고리즘에 대한 유효성 검증을 계산적으로, 효율적으로 스마트 컨트랙트에서 수행할 방법이 아직 없기 때문이다. 또한 메모리 I/O 병목을 이용하는 블록체인은 검증에 막대한 저장 공간을 요구하므로 스마트 컨트랙트에서 처리할 수가 없다. 이 경우 검증을 우회할 여러 기법들이 추가 요구된다. 프라이버시 블록체인: 기밀 트랜잭션이나 스텔스 주소를 사용하는 프라이버시 블록체인의 트랜잭션을 외부의 다른 블록체인에서 검증할 방법에 대한 고찰이 필요하다. 컨트랙트 호출 비용: 주기적으로 블록 헤더를 등록하고 검증하기 위한 비용과 머클 증명을 검증하기 위한 비용 등이 과다하게 청구될 수 있다. 이를 극복하기 위한 여러 연구들이 진행되어 왔으며, 현재에도 진행 중에 있다. “Retrofitting a two-way peg between blockchains”의 “Open problems” 절에 잘 설명되어 있으니 궁금한 사람은 참고하면 좋을듯 하다.","link":"/2021/12/18/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%83%81%ED%98%B8%EC%9A%B4%EC%98%81%EC%84%B1/"},{"title":"[Blockchain] 블록체인 합의알고리즘(Finality,Safety,Liveness)","text":"🚫 Finality블록체인에서 finality의 의미는 블록이 한 번 블록체인에 포함(import)되고 나면 되돌릴 수 없음을 의미한다. finality 보장 방법은 합의 알고리즘 설계에서 가장 중요한 문제 중 하나이다. finality는 크게 확률적 finality와 절대적 finality 두 종류로 분류한다. 확률적 finality확률적 finality는 블록을 되돌릴 수 없다는 것을 확률적으로만 보장한다. 비트코인 나카모토 합의 알고리즘이 사용하는 방식으로 블록이 추가로 생성될 수록 앞쪽에 있는 블록의 finality가 확률적으로 증가하는 방식이다. 오래된 블록을 되돌리기 위해서는 많은 컴퓨팅 파워가 필요하기 때문에 어느 정도 오래된 블록은 사실상 되돌리는 것이 불가능해진다. 거래소에 비트코인을 입금하면 6개의 블록 컨펌을 기다린 이후 거래가 가능한 이유도 거래소 입장에서 확률적으로 finality를 체크하기 때문이다. 절대적 finality절대적 finality는 한 번 블록이 블록체인에 포함되면 어떤 경우에도 해당 블록을 되돌릴 수 없음을 보장하는 방식이다. 주로 텐더민트와 같은 BFT 계열의 합의 알고리즘이 절대적 finality를 보장하는데, 텐더민트의 경우 블록이 전체 노드 voting power의 2/3 prevote와 2/3의 precommit을 받으면 해당 블록은 즉시 finalize가 된다. CAP Theorem확률적 finality와 절대적 finality의 속성을 비교하면 당연히 절대적 finality가 좋다. finality만 봤을 때는 모든 체인이 BFT 계열의 합의 알고리즘을 사용해야 한다고 생각할 수 있다. 하지만 모든 엔지니어링은 트레이드오프가 있고, 절대적 finality 역시 공짜로 얻어지는 것은 아니다. 이 문제를 이해하기 위해서는 Eric Brewer’s CAP 정리를 살펴볼 필요가 있다. CAP 정리에 따르면 모든 분산 컴퓨팅 시스템은 Consistency, Availability, Partition Tolerance 중 2가지만 달성 가능하다. 참여 노드가 전세계에 분산된 블록체인의 경우 네트워크 파티션을 피할 수 없으므로, 모든 체인은 Consistency와 Availability 둘 중 하나를 선택해야 한다는 뜻이기도 하다. 확률적 finality를 선택한 체인은 네트워크 파티션 상황에서 Availability를 보장한다. 비트코인의 경우 네트워크 파티션이 발생하면 각 파티션에 포크가 생기게 되고, 네트워크 파티션이 사라지면 longest-chain 규칙에 따라 다시 하나의 체인으로 합쳐지게 된다. 포크가 난 상황에서도 계속 합의를 진행할 수 있지만, finality는 보장하지 못한다. 반대로 절대적 finality를 선택한 체인은 네트워크 파티션 상황에서도 Consistency를 보장한다. 텐더민트의 경우 네트워크가 반으로 파티션되면 어느 한 쪽도 2/3의 투표를 받지 못하기 때문에 블록에 대한 합의를 진행하지 못한다. 이후 네트워크 파티션이 사라지면 다시 합의를 진행하게 된다. 파티션 상황에서 Availability를 보장하지 못하는 대신 절대적 finality를 보장할 수 있다. 하나의 체인이 모든 종류의 Dapp을 지원하기 어려운 이유도 여기에 있다. 어떤 Dapp은 Consistency가 중요하고 어떤 Dapp은 Availability가 중요할 수 있다. Dapp 개발자는 Finality 보장에 숨어 있는 트레이드오프를 이해하고 Dapp의 성격에 맞는 적절한 체인을 선택하는 것이 좋다. 🦺 Safety와 Liveness어떤 합의 알고리즘이 네트워크에서 통용되기 위해선 Safety와 Liveness라는 특성을 가지고 있어야 한다. Safety의 의미는 ‘노드 간 합의가 발생했다면, 어느 노드가 접근하든 그 값은 동일해야 한다’이다. 블록체인의 finality와 동일한 개념으로 이해해도 된다. Liveness는 ‘합의 대상(Transaction 또는 블록체인에서 블록)에 문제가 없다면, 네트워크 내에서 반드시 합의가 이루어진다’라는 의미이다. FLP impossibility하지만, 비동기 네트워크 내에서는 Safety와 Liveness를 모두 완벽히 만족하는 합의 알고리즘을 설계하는 것이 불가능하다는 것이 증명되었다. 이 증명을 “FLP Impossibility”(논문 작성자: Fischer, Lynch, Paterson라고 한다. 정확히 말하면, 비동기 네트워크에서는 합의 문제를 완벽히 해결할 수 있는 분산 알고리즘이 없다는 것을 증명했다. 1985년 4월 발표된 논문 Impossibility of Distributed Consensus with One Faulty Process에서 언급된 내용이다. 비동기 네트워크에서는 어떤 한 노드에서 문제가 발생했을 경우 그 노드에서 합의가 됐는데 단순히 응답에 오랜 시간이 걸리는 건지, 아니면 합의 과정에서 충돌이 발생해서 응답하지 않는 건지 알 수 없기 때문이다. 블록체인이 구동되는 네트워크는 비동기 네트워크이다. 따라서 비동기 네트워크에서 완벽한 합의 알고리즘은 존재하지 않는다. 다시 말해, Safety와 Liveness를 동시에 완벽히 만족하는 합의 알고리즘을 설계할 수가 없다. 즉 블록체인에서 어떤 합의 알고리즘을 채택한다는 것은, Safety와 Liveness 중 하나를 어느 정도 포기해야 한다는 것을 말한다. Replication System은 싱글 호스트 시스템에게 고가용성(High Availability) 제공할 수 있지만, Replica 간의 네트워크 오류나 Replica자체 고장 등의 문제로 여전히 정상 동작되지 않을 수 있는데, 합의 알고리즘은 이러한 문제들을 다룰 수 있어야 하고, 일반적으로 다음 두 개의 시스템 속성을 만족시켜야 한다. • Safety: 시스템에 나쁜 일이 발생하지 않는다는 의미이며, 모든 정상적인 Replica는 같은 상태에 동의하여야 하고, 그 상태는 유효해야 한다. (노드간에 합의가 발생했다면, 어느 노드에 접근하던 그값은 동일해야 함.) • Liveness: 시스템은 항상 살아 있어야 한다는 의미이며, 결국에는 어떤 상태에 동의하여야 하고, 모든 Replica는 동의된 상태에 도달해야 한다. (합의대상 (Transaction, Block)에 문제가 없다면 네트워크 내에 반드시 합의가 이뤄져야 함) Replica의 비정상적인 상황을 크게 두 가지로 구분할 수 있는데, Fail-stop은 단순히 노드가 고장이 나서 멈추는 형태의 오동작인 반면(Non-Byzantine), Byzantine-Fault는 리플리카가 악의적인 행동을 포함하여 임의의 동작을 할 수 있는 것을 의미한다. ​ Fail-stop 형태의 대표 합의 프로토콜에는 Paxos와 Raft가 있고, Byzantine-Fault 의 대표 합의 프로토콜은 PBFT가 있다.","link":"/2021/12/19/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%95%A9%EC%9D%98%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Finality-Safety-Liveness/"},{"title":"[Blockchain] 블록체인 합의알고리즘(PBFT, Sieve, Tendermint, Raft, Paxos, PoA)","text":"PBFT(Practical Byzantine Fault Tolerance)PBFT는 PoW나 PoS와 마찬가지로 Byzantine Fault 모델이지만 PoW와 PoS의 단점인 파이널리티의 ‘불확실성’과 ‘성능 문제’를 해결한 것이다. Safety를 확보하고 Liveness를 일부 희생하였다. 즉, 네트워크에 배신자 노드가 어느 정도 있다고 해도 네트워크 내에서 이루어지는 합의의 신뢰를 보장하는 알고리즘이다. 현재까지 블록체인 합의 알고리즘 중 BFT 방식을 채택했다고 하는 경우 대부분 PBFT 합의 알고리즘을 바탕으로 조금씩 변형을 가했다고 볼 수 있다. 대표적으로 Tendermint는 PBFT에 DPoS 합의 알고리즘을 결합했으며, 이더리움 Casper는 PoW 방식의 채굴 위에 PoS + PBFT 형태의 블록 검증 시스템을 제안했다. 이외에도 PBFT는 Hyperledger Fabric, R3, Ripple, EOS에 이르기까지 Public과 Private을 가리지 않고 다양한 블록체인에서 사용되고 있다. PBFT는 네트워크의 모든 참여자를 미리 알고있어야 한다(prepared certificate). 참가자 1명이 프라이머리(Primary, 리더)가 되고 자신을 포함한 모든 참가자에게 요청을 보낸다. 그 요청에 대한 결과를 집계한 뒤 다수의 사용해 블록을 확정한다(commit certificate). 부정한 노드 수를 n개라고 하면 노드 수는 3n+1개여야 하며, 확정에는 n+1개 이상의 노드를 필요로한다. 비잔틴 장군 문제의 상황n개의 비잔틴 부대가 적의 도시를 포위하고 있고, 각 부대는 부대마다 배치된 장군의 명령에 따른다. 한명의 장군은 나머지 n-1명의 장군과 통신할 때 각각의 장군에게 전령을 보내는 것으로만 통신 할 수 있다. 장군들은 지금 총 공격을 할 지, 조금 더 기다릴 지 합의하여야 한다. 그러나, 장군들 중 배신자가 있을 수 있고, 배신자들은 근거없이 아무 의견이나 제시 할 수 있는 가능성이 있다. 따라서 배신한 장군들의 방해를 뚫고 공격 여부를 합의할 방법(알고리즘)이 필요하게 된다다. 처리 절차 클라이언트가 모든 노드에 요청을 브로드캐스트 한다. Leader가 primary(리더)가 되고 순차적으로 명령을 다른 노드에 전달한다. 각 노드는 브로드캐스트 된 명령을 받게 되면 Leader를 포함한 모든 노드에 회신을 한다. 각 노드는 전달된 명령을 일정 수 이상 (2n) 이상 수신하면 Leader를 포함한 모든 노드에 수신한 신호를 재 전송한다. 각 노드는 수신된 명령을 일정 수 이상(2n)수신하면 명령을 실행하고 블록을 등록해 client에 replay된 메세지를 반환한다. PoW나 PoS와는 달리 다수결로 의사결정한 뒤 블록을 만들기 때문에 블록체인의 분기가 발생하지 않습니다. 따라서 한 번 확정된 블록은 변경되지 않기 때문에 파이널리티를 확보할 수 있습니다. 또한 PoW와 같이 조건을 만족시킬 때까지 계산을 반복하지 않아도 되기 때문에 매우 고속으로 동작합니다. 부정 사용을 하고자 해도 과반수를 획득해야 하며 만약 프라이버리가 거짓말을 한다 해도 모든 참가자가 리더의 움직임을 감시해 거짓말이라고 판단한다면 다수결로 리더 교체를 신청할 수 있기 때문에 장애에 매우 강력한 내성을 지닌 알고리즘이다. 하지만, 언제나 참가자 전원과 의사소통을 해야 하기 때문에 참가자가 증가하면 통신량이 증가하고 처리량이 저하되는 문제점을 가지고 있다. PoW나 PoS는 수천개의 노드를 만들 수 있지만 PBFT는 수십개의 노드가 한계이다. SieveSieve는 IBM에서 고안한 PBFT를 확장한 알고리즘 이다. Hyperledger fabric에 채택되어 있지만 2016년 7월 시점 기준으로 대상에서 제외되었다. 실행결과 전송과 집계 결과 전송으로 흐름이 나뉜 것이 특징이며 합의 형성 전 단계에서 실행 결과를 검토해 결과가 다른 경우 중지(Abort)시킨다. 각 노드의 실행 결과가 다를 가능성을 조기에 탐지하고 싶은 경우에 유효하다. 집계 결과 전송에 PBFT가 채택되는 경우가 많기 때문에 처리 절차는 PBFT보다 많다. 처리 절차 각 노드 중 한명이 client가 되고 리더의 명령을 송신힌다. 리더가 각 노드에 실행의뢰를 전송한다. 각 노드는 의뢰를 실행하고 결과를 리더에게 전달한다. 결과가 일정 수에 도달하지 못하면 중단(abort)되며 요청은 무시된다. 수신한 결과가 중지가 아니라면 그 증거로 결과를 집계한다. (이 때 통신에 PBFT가 사용되는 경우가 많다.) TendermintTendermint는 PBFT 알고리즘을 개량하여 공개 또는 비공개(Public &amp; Private) 블록체인에 맞도록 개량한 증명 방식이다. Tendermint의 전체 합의 프로세스는 PBFT와 거의 유사하다. 여기에 DPOS개념을 추가하여 블록체인에 적합한 합의 알고리즘을 개발하였다. Tendermint는 지분(Stake)을 기반으로 투표한다. 투표를 할 때에는 참여한 지분을 일차적으로 네트워크에 동결하고, 합의 이후에 이를 해제하는 Locking 메커니즘을 통해 이중 투표 문제를 막고 네트워크에 지분을 유지하도록 한다. 또한, 이중 투표 시도와 같은 블록체인을 공격하려는 악의적인 행위를 하면 지분을 빼앗는 방법을 도입했다. 기존의 블록체인이 네트워크 공격 노드에 아무런 처벌을 하지 않던 문제(Nothing of Stake)문제를 해결한다. Paxos가장 유명한 합의 알고리즘 중 하나이다. 데이터베이스를 복제할 때는 동일한 서버를 하나 더 만들어 데이터를 복제하는 것이 일반적이다(Replication System). 하지만, 블록체인에서는 이런 복제시스템을 사용한 사례가 아직 없다. Paxos의 코어는 매우 단순하지만, 이 알고리즘은 합의 형성에만 특화됐기 때문에 프로그램으로 구현하기 위해서는 시스템적으로 검토해야 할 점이 많다. Paxos의 특징은 과반수의 동의를 얻었다면 그 동의 내용이 나중에 변경되지 않는다는 점이다. 리더를 중심으로 합의 형성을 수행하지만 Byzantine Fault 모델이 아니기 때문에 리더가 부정을 저지르는 경우 동기화되지 않는다. 그리고 맴버가 거짓으로 신고한 경우에도 동기화가 되지 않기 때문에 악의를 가진 참가자가 있는 환경에서는 운영하기에는 적절하지 않다. RaftPaxos를 보다 이해하기 쉽게 만들기 위해 고안된 알고리즘 이다. 기본적으로 복제된 state machine 구조를 가지며, 클라이언트 요청을 하나의 리더 노드가 처리하여 로그를 업데이트하고 해당 로그가 다른 리플리카에도 반영되도록 하는 형태로 동작한다. 리더가 문제가 있을 경우 리더 선출 프로토콜에 따라 새롭게 리더를 선출한다. Viewstamped Replication, Zab(ZooKeeper Atomic Brodcast) 프로토콜도 같은 계열의 프로토콜이라고 할 수 있다. PoAPoA(Proof of Authority)는 신분에 기반한(identity as a stake) 합의 매커니즘을 통해 즉각적인 거래를 제공하는 블록체인과 함께 사용되는 알고리즘 이다. PoA라는 용어는 Ethereum과 Parity Technologies의 공동 창업자인 Gavin Wood가 제안하였다. PoA기반 네트워크에서 트랜잭션 및 블록의 유효성 검사기(validators)라고 하는 승인된 계정(이더리움 내에서 accounts 개념)에 의해 유효성이 검사되는 알고리즘 이다. validators는 트랜잭션을 블록 단위로 넣을 수 있는 소프트웨어를 실행고, 이 과정은 자동화되어 있으며 검사자가 컴퓨터를 지속적으로 모니터링 할 필요가 없다. 신원은 공개적으로 사용 가능한 도메인의 정보를 교차 점검 할 수 있는 체인을 통해 공식적으로 확인되어야 한다. 블록을 획득하고 가치를 인정할 수 있는 권라를 얻기 위해서는 자격을 갖추어야 한다. (validator 후보는 공증인(notary)자격을 먼저 취득해야 한다.) 예시를 들자면 ‘랜딩블록 뱅킹’이라는 프라이빗 블록체인을 사용하려는 집단을 가정 할 때, 농협, 우리은행, 신한 은행, 국민은행 등과 같이 확실한 신원이 보장된 기관들만 참여하는 방식이다. 이에 ‘랜딩블록 뱅킹’ 이라는 프라이빗 블록체인의 validator를 ‘농협’과 ‘우리은행’으로 지정해 버리는 것이다. 즉, 블록체인 노드를 담당하여 전송 및 블록생성을 담당한다. 이러한 방법은 노드 수를 줄여 유효성 검사에 필요한 시간을 줄일 수가 있으며, 블록 생성주기를 짧게하여 빠른 트랜잭션 처리가 가능하다. 하지만, 블록체인의 핵심 개념인 ‘탈 중앙화’와는 비교적 멀어지는 편이다. PoA를 통해 개인은 validator가 될 수 있는 권리를 얻으므로 그들이 얻은 지위를 유지할 인센티브가 있다. 신원 정보에 명성을 첨부함으로써 validator는 자신의 신원에 부정적인 평판이 생기길 원치 않으므로 트랜잭션 프로세스를 유지하기 위해 노력하게 된다. PoETPoET(Proof of Elapsed Time)는 작업증명(PoW) 방식의 경쟁적 해싱 연산으로 낭비되는 에너지를 줄이면서 작업 증명(PoW)과 유사한 Security를 보장하기 위해 비교적 최근에 제시된 방식이다. 하이퍼레저 쏘투스 레이크(Sawtooth Lake)에서 제안된 합의 알고리즘이다. 신뢰할 수 있는 보안 모듈(intel SGX)을 기반으로 블록을 생성하는 리더를 랜덤으로 선정한다. 가능한 다수의 노드가 합의에 참여하여 공정하게 리더를 선정하도록 한다. 보안 CPU 명령을 사용하여 리더를 선정함으로써 안전성과 무작위성을 보장한다. 마이너의 동작을 시스템 보안 모듈인 enclave에서 수행되도록 함으로써 원천적으로 악의적인 노드의 개입을 막는다. 리더 선정 비용이 낮아 다수의 검증인들이 참여할 수 있으므로 합의 알고리즘의 견고성이 증가한다는 장점이 있지만, intelSGX에 의존한다는 단점이 있습니다. IBFTIBFT(Istanbul Byzantine Fault Tolerance)는 즉각적인 최종성을 보장하는 권한 증명(PoA) 블록체인 합의 알고리즘이다. PBFT의 Validator Set는 정적이지만 IBFT에는 동적 Validator Set가 있다는 점에서 PBFT와 다르다. 이를 통해 IBFT 합의 메커니즘 기반 블록 체인은 PBFT 합의 메커니즘 기반 체인보다 빠르게 트랜잭션을 확인할 수 있다. 작동 방식은 다음과 같다. 시작하려면 노드 그룹을 선택하여 Validator Pool을 구성한다. 이 노드는 제안된 블록이 체인에 추가하기에 적합한 지 결정하는 역할을 한다. 이러한 Validator 노드 중 하나는 Proposer로 임의로 선택된다. Validator Pool로부터 메시지를 받은 이 Proposer는 체인에 무엇을 추가할지 결정한다. 이것은 다른 Validator에게 제안된 블록으로 제공된다. 다수의 Validator가 블록이 유효하다고 판단하는 경우에만 원장(ledger)에 추가된다. 각 합의 라운드가 끝날 때마다 Validator는 새로운 Proposer를 선택하고 동일한 프로세스가 반복된다. 합의 알고리즘에서 고려 사항 완결성 문제 51%공격과 비잔틴 결함 트랜잭션 수수료","link":"/2021/12/20/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%ED%95%A9%EC%9D%98%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-PBFT-Sieve-Tendermint-Raft-Paxos-PoA/"},{"title":"[Blockchain] 블록체인 암호화폐 개념","text":"디지털화폐디지털화폐디지털화폐(digital money)는 금전적 가치를 은행권·동전과 같이 물질인 방식이 아니라 디지털 방식으로만 사용될 수 있는 유형의 화폐를 가리킨다. 이것은 암호화하여 IC카드에 저장하고 휴대하여 사용하거나 컴퓨터에 보관하고 네트워크상으로 사용하는 것을 모두 포함한다. 암호화폐는 디지털화폐에 속한다. 또한 디지털화폐는 전자화폐와 같은 뜻으로 사용되기도 하지만, 전자화폐는 디지털화폐보다 좁은 개념이 된다. 즉, 암호화폐와 전자화폐 모두 디지털화폐라고 할 수 있다. 전자화폐지급 결제의 수단으로 화폐 대신에 기존의 화폐가 가지는 성질을 전자적인 정보로 변환시킨 것으로, 전자 금융 환경이 만들어낸 차세대 화폐 개념이다. 지금의 주화나 지폐를 대체하는 일종의 ‘현금’으로 소액거래가 주목적이다. 전자화폐는 운용방식에 따라 ‘네트워크형’과 ‘IC(Intergrated Circuit)카드형’으로 나뉜다. 국내의 경우 소액 결제형 카드인 ‘e코인’을 시작으로 금융결제원에서 한국형 전자화폐인 ‘K캐시’가 사용되었다. 가장 대중화되었던 형태로는 교통카드이며, 최근에는 스마트폰의 대중화로 모바일에 전자화폐의 기능을 설치하여 사용함으로써 모바일 전자화폐 시장이 확대되고 있다. 암호화폐암호화폐(暗號貨幣, cryptocurrency)는 암호 기술을 이용하여 만든 디지털 화폐이다. 암호화폐는 네트워크로 연결된 인터넷 공간에서 암호화된 데이터 형태로 사용된다. 암호화폐는 지폐나 동전과 같은 실물이 없이 디지털 데이터 형태로 존재하기 때문에 가상화폐(假想貨幣, virtual money)라고도 볼수있다. 암호화폐는 결제 수단으로 사용되기보다는 자산의 안전한 보관을 위해 사용되는 경우가 많아서 암호자산(暗號資産, crypto asset)이라고 부르기도 한다. 대부분의 암호화폐는 탈중앙화된 피투피(P2P) 방식의 블록체인(blockchain) 기술을 이용하여 가치를 저장·전송한다. 암호화폐는 해시(hash)라는 암호화 기술을 이용하여 만든 전자화폐의 일종으로서, 가치를 보증하는 중앙은행이 없이도 거래의 신뢰성과 안전성을 보장받을 수 있다. 암호화폐는 국가의 제약이 없는 글로벌 통화로서, 일종의 디지털 골드(digital gold)라고 할 수 있다. 암호화폐는 흔히 가상화폐라는 말로 혼용되어 사용되기도 하지만, 엄밀히 말하면 서로 구별되는 개념이다. 암호화폐는 암호화 기술을 이용하여 만든 화폐이고, 가상화폐는 실물이 없이 가상으로 존재하는 화폐이다. 예를 들어, 비트코인, 이더리움, 이오스 등은 암호화폐이고, 싸이월드 도토리, 리니지 아덴 등은 가상화폐이다. 암호화폐는 암호화 기술을 이용하여 만든 가상화폐의 일종이다. 결국, 암호화폐는 가상화폐의 한 종류이다. 전자화폐와 암호화폐의 차이전자화폐는 법이 존재하고 발행 허가도 받아야 되기 때문에 전자화폐는 안정적이고 자금 보호가 보장되는 법정화폐이다. 반대로, 암호화폐는 법규가 없고 발행허가를 받지 않아도 되지만 그만큼 안정적이지 못하고 보호를 받기 힘들기 때문에 위험한 신용요소가 될 수 있는 화폐이다. 예를 들어, 게임머니나 포인트에서 사용되는 포인트들과 전자화폐는 인터넷에서 동일하게 사용할 수 있다는 점에서 공통점을 갖지만, 게임머니와 포인트는 게임 안에서만 존재한다. 하지만 전자화폐는 전 세계에서 사용할 수 있다는 점이 다르다. 그리고 전자화폐는 원화의 형태가 바뀐 것이지만, 비트코인과 같은 암호화폐는 달러(Dollar)처럼 하나의 통화로 사용한다는 차이점이 있다. 중앙은행 디지털화폐중앙은행 디지털화폐(CBDC, Central Bank Digital Currencies)는 실물 명목화폐를 대체하거나 보완하기 위해 중앙은행이 직접 발행하는 디지털화폐이다. 기존 기준예치금도 그 형태상 중앙은행 디지털화폐와 유사하나, 중앙은행이 새로이 발행하는 전자화폐를 중앙은행 디지털화폐로 정의한다. 이용 목적에 따라 모든 경제주체들의 일반적인 거래에 사용되는 소액 결제용 중앙은행 디지털화폐와 은행 등 금융기관간 거래에 사용되는 거액결제용 중앙은행 디지털화폐로 구분 가능하다. 중앙은행 디지털화폐는 전자적 방식으로 구현됨에 따라 현금과 달리 관련 거래의 익명성을 제한할 수 있을 뿐만 아니라 정책목적에 따라 이자 지급, 보유한도 설정, 이용시간의 조절도 가능하다. CBDC는 발행 대상에 따라 일반적인 소액결제용과 금융기관간 거액결제용으로 구분할 수 있다. 전자적 방식으로 구현됨에 따라 현금과 달리 익명성을 제한할 수 있고, 이자지급이 가능하며, 보유한도 설정, 이용시간 조절도 가능하다. 미국 달러화는 USDT, 일본 엔화는 JPN코인, 페이스북의 리브라 등이 있다. 민간기업인 페이스북의 리브라는 중앙은행의 견제를 받아 프로젝트를 재정비하고 있다. DAO, ICO, DAICODAO다오(DAO, Decentralized Autonomous Organization)란 탈중앙화된 자율조직에서 따온 말로 인공지능을 운영해 탈중앙화된 네트워크를 뜻한다. 이더리움 창시자인 비탈릭 부테린(Vitalik Buterin)을 필두로 이더리움 개발진들이 개발한 시스템이다. 분산형 자치 조직은 블록체인 기술을 사용하여 안전한 디지털 장부가 인터넷상의 금융 상호 작용을 추적하고 신뢰할 수 있는 타임스탬프 작성 및 분산 데이터베이스 배포로 위조되지 않도록한다. 이 접근법은 금융 거래에서 상호 신뢰 할만한 신뢰받는 제 3자를 참여시킬 필요가 없으므로 거래를 단순화한다. 블록체인 사용 트랜잭션 및 관련 데이터보고의 비용은 신뢰할 수있는 제3자와 서로 다른 레코드의 계약 교환을 반복적으로 기록해야 할 필요성을 모두 제거함으로써 상당 부분 상쇄 될 수 있다. 예를 들어 블록체인 데이터는 원칙적으로 규제 구조가 허용하는 경우 증서 및 제목 과 같은 공개 문서를 대체 할 수 있다. 자율 에이전트(Autonomous agents),탈중앙화된 앱(Decentralized applications: Dapps),탈중앙화된 조직(Decentralized organizations: DOs),탈중앙화된 자율 조직(Decentralized autonomous organizations -DAOs),탈중앙화된 자율 회사(Decentralized autonomous corporations/companies),완전 자동화된 기업(Fully Automated Business entity:FAB)의 개념을 통틀어 DAO 네트워크로 지칭한다. 탈중앙화 즉 어떤 조직도 소유하지 않고 자율적으로 합의하의 프로세스가 실행되며 분산화된 시스템으로 움직이게 된다. 쉽게 말해 이더리움으로 투자할 수 있는 펀드의 개념으로 생각하면 이해하는 데 도움이 된다. 이더리움으로 DAO 토큰을 구매해서 DAO 펀드에 투자하게 된다. ICOICO(Initial Coin Offering)는 암호화폐를 통해 자금을 모집하는 방법 중 하나이다. 완전한 개발이 되지 않은 블록체인 플랫폼, 상품 또는 서비스와 같은 프로젝트에 가장 많이 사용된다. 결제는 보통 비트코인 또는 이더리움으로 이뤄지며, 종종 명목화폐를 수용하기도 한다. 투자자들은 해당 회사가 성공할 것이며, 수요가 증가하여 코인 가격 상승으로 이어질 것이라는 희망과 기대를 가지고 ICO에 참여한다. 다른 말로 하자면, 투자자들은 특정 암호화폐 프로젝트의 초기 지지자로서 좋은 투자자본수익률(ROI, Return on Investment)을 기대한다. 다만, ICO의 경우 중재를 통한 참여가 아닌 직접 참여이기 때문에 참여자가 프로젝트에 대해 직접 검증을 해야 하는 부분은 단점으로 작용할 수도 있다. 잘못된 ICO에 참여하면 유동성이 부족한 토큰을 구매하게 되거나 스캠, 이른바 사기에 당하는 경우도 있기 때문이다. ICO로 획득한 토큰이 거래소에 상장된 후, 해당 암호화폐의 거래가 활성화될 경우 높은 실적을 기대할 수 있지만, 소중한 자산을 움직이는 만큼 충분한 사전 조사를 통해 신뢰할 수 있는 프로젝트를 선별하는 개인의 노력이 필요하다. ICO는 크라우드펀딩(crowdfunding)의 일종으로서, 초기코인공개 또는 초기코인제공이라고 한다. 즉, 새로운 암호화폐를 만들기 위해 불특정 다수의 투자자들로부터 초기 개발 자금을 모집하고 그 대가로 코인을 나눠주는 행위이다. 주식 공개 모집을 의미하는 IPO에서 나온 말이다. ICO를 진행하기 위해 새로운 암호화폐를 만들게 된 동기, 목적, 운영 방식, 전망 등의 내용을 담은 백서(white paper)를 발행하고, 초기 투자자를 모집한다. DAICO다이코(DAICO, Decentralized Autonomous Initial Coin Offering의)란 탈중앙화 자율조직을 의미하는 DAO와 초기코인공개인 ICO의 합성어로서, 탈중앙화 자율관리 초기코인공개라고 번역할 수 있다. DAICO는 ICO를 통해 모금한 자금을 개발팀에 한꺼번에 전달하지 않고, 실제 개발이 진행되는 상황에 맞추어 단계적으로 지급하는 방식의 자금 운용 방식을 말한다. 만약 암호화폐 백서에서 약속한 내용을 지키지 못할 경우, 이미 모금한 자금을 개발팀에 전달하지 않고 투자자들에게 환불할 수도 있다. 이더리움의 창시자인 비탈릭 부테린이 2018년 1월 기존 ICO의 문제점을 지적하면서, 그 대안으로 제시한 새로운 자금 투자 및 운영 방안이다 다이코는 탭 기능, 환불 기능을 가지고 있고 이로 인해 암호화폐 시장이 투명해지고 정확해졌다. 최초의 다이코를 사용한 암호화폐 회사는 ABYSS이다. 다이코를 도입 후 엄청난 결과를 이끌었다. 투자자들도 안전하게 투자를 하고 개발자들은 프로젝트를 인정받기 시작했다. 그리고 암호화폐 시장이 우리나라에게 인기를 끌고 있다. 다이코도 완벽한 제품이 아니라서 문제점이 있지만 출시일이 매우 적기 때문에 시간이 흐른다면 완벽한 자금 투자 및 암호화폐 운영이 수월하게 될 수 있다. 코인과 토큰","link":"/2021/12/21/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%95%94%ED%98%B8%ED%99%94%ED%8F%90-%EA%B0%9C%EB%85%90/"},{"title":"[Blockchain] 블록체인-암호학(Hash, PKI, ECDSA, ZKP)","text":"해시(Hash)해시(hash)란 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑(mapping)한 값이다. 해시값이라고도 한다. 이를 이용해 특정한 배열의 인덱스나 위치나 위치를 입력하고자 하는 데이터의 값을 이용해 저장하거나 찾을 수 있다. 기존에 사용했던 자료 구조들은 탐색이나 삽입에 선형시간이 걸리기도 했던것에 비해, 해시테이블은 key-value가 1:1로 매핑되어 있기 때문에 삽입, 삭제, 검색의 과정에서 모두 평균적으로 O(1)의 시간복잡도를 가지고 있다. 해시는 암호학에 있어서 매우 중요한 요소이며, 블록체인(blockchain)을 구현하기 위한 핵심 기술이다. 특징무결성해시는 특정한 데이터를 이를 상징하는 더 짧은 길이의 데이터로 변환하는 행위를 의미한다. 여기서 상징 데이터는 원래의 데이터가 조금만 달라져도 확연하게 달라지는 특성을 가지고 있어 무결성을 지키는 데에 많은 도움을 준다. 보안성해시는 애초에 복호화를 수행할 수 없도록 설계되었으며, 실제로도 해커가 쉽게 복호화를 할 수 없다는 점에서 강한 보안성을 가진다. 비둘기집 원리비둘기가 5마리일때 상자가 4개밖에 존재하지 않는다면 아무리 비둘기를 균등하게 분배해도 최소한 한 상자에는 2마리의 비둘기가 들어가게 된다. 이러한 원리를 비둘기집 원리라고 말한다. 이 원리에 따라 해시에서는 ‘서로 다른 입력 값의 해시 결과 값이 동일한 문제’ 즉, 해시 충돌이 발생할 여지가 있다. 해시 레이트해시 레이트란 연산 처리능력을 측정하는 단위로 해시 속도를 의미한다. 일반적으로 해시레이트가 높아져 연산량이 많아질 경우, 더 빠른 채굴이 이루어지기 때문에 채굴 난이도가 높아진다. 공개키 기반구조(PKI)PKI(Public Key Infrastructure)는 공개키 기반구조라고 하며, 디지털 증명서의 생성, 관리, 배포, 사용, 저장 및 파기, 공개키 암호화의 관리에 필요한 역할, 정책 등 일련의 절차들을 집합한 것이다. PKI의 목적은 전자상거래, 인터넷 뱅킹 및 기밀 전자 메일과 같은 다양한 네트워크 활동을 위한 정보의 안전한 전자 전송을 보다 빠르게 촉진시키고 사물인터넷(IOT)을 위한 안전하고 신뢰할 수 있는 비즈니스 환경에 필수적인 요소제공이다.단순한 패스워드가 부적절한 인증 방식이며, 통신에 관계된 당사자의 신원을 확인하고, 전송되는 정보의 유효성을 확인하기 위한 보다 엄격한 증거가 필요한 활동에 대해 요구된다. 즉 암호화와 복호화키로 구성된 공개키를 이용해 송수신 데이터를 암호화하고 디지털 인증서를 통해 사용자를 인증하는 시스템을 말한다. 특징PKI는 공개키에 대한 인증서를 발급하는 ‘인증기관(CA)’, 사용자들의 인증서 신청 시 인증기관 대신 그들의 신분과 소속을 확인하는 ‘등록기관(RA)’, 인증서와 사용자 관련 정보, 상호 인증서 쌍 및 인증서 취소 목록 등을 저장·검색하는 장소인 ‘디렉터리 서비스(DS)’, 또한 다양한 응용에서 공개키를 이용하여 전자서명을 생성하고 검증하며 데이터에 대한 암호, 복호를 수행하는 사용자 등으로 구성된다.​ PKI를 도입하여 전자상거래를 할 경우, 전자상거래를 위해 전자서명을 한 뒤 공인인증기관의 인증을 받아 상대에게 제시하여 거래가 이뤄짐으로써 개인정보나 거래정보가 외부에 노출되지 않아 안전하게 거래할 수 있다. PKI의 구성요소 타원곡선 디지털서명 알고리즘(ECDSA)타원곡선 디지털서명 알고리즘(ECDSA, Elliptic Curve Digital Signature Algorithm)은 타원곡선암호를 전자서명에 접목시킨 암호 알고리즘이다. 이는 비트코인, 이더리움 등의 암호화폐 거래 시 정당한 소유주만이 자금을 쓸 수 있도록 하기 위해 사용된다. 블록체인 네트워크에서 트랜잭션을 주고받을 때, 수신자가 인증자의 공개 키로 메시지가 진짜인지 검증하기 위해서는 전자서명을 필요로 한다. 이 전자서명은 개인 키로만 생성 가능하고 수신인이 트랜잭션에 쓰여있는 전자서명이 정말 발신인의 전자서명이 맞는지 확인할 수 있어야 하는데, 이 두 조건을 고루 만족시키는 기술이 타원곡선암호이다. 타원곡선 디지털서명 알고리즘을 통해 암호화폐 거래 시 정당한 소유자만이 자금을 쓸 수 있도록 할 수 있으며 대표적으로 비트코인과 이더리움에서 타원곡선 디지털서명 알고리즘을 사용한다. 타원곡선암호(ECC)타원곡선암호(ECC, Elliptic Curve Cryptography)는 타원곡선을 기반으로 한 암호방식으로, 대표적인 공개키 방식 중 하나이다. 타원곡선암호 기술은 기존 RSA 암호방식에 대한 대안으로 1985년도에 제안된 방식이다. 비트코인이 타원곡선암호 기술 방식에 속하는 타원곡선 디지털서명 알고리즘(ECDSA) 암호 알고리즘을 사용하고 있다. 타원곡선암호는 타원곡선 암호화 알고리즘이라고도 부른다. 영지식 증명(ZKP)영지식증명(零知識證明, zero-knowledge proof)이란 거래 상대방에게 어떠한 정보도 제공하지 않은 채, 자신이 해당 정보를 가지고 있다는 사실을 증명하는 것을 말한다. 영어로 ZKP(지케이피)라고도 한다 현대 암호학에서는 영지식증명을 다자간의 비대면 통신 프로토콜에서 정보보호 기능을 제공하기 위해 암호기술을 적용하는 암호 프로토콜 중 매우 중요한 고급 암호 프로토콜의 한 종류로 취급한다. 암호화폐에서 영지식증명은 2013년 존스홉킨스 대학교의 연구진들이 실행한 제로코인(ZeroCoin)에서 처음 적용이 되었다. 제로코인은 2014년 제로캐시(Zero Cash)라는 이름을 거쳐, 2016년 지캐시(Zcash)라는 이름으로 변경되었다. 영지식증명은 간단히 말해 증명자가 자신이 알고 있는 지식과 정보를 공개하지 않으면서, 그 지식을 알고 있다는 사실을 검증자에게 증명하는 시스템이다. 여기서 증명자(prover)는 자신이 해당 지식을 알고 있음을 증명하는 주체이며, 검증자(verifier)는 증명자가 해당 지식을 알고 있다는 사실을 검증해주는 주체이다. 특징영지식 증명은 3가지 조건을 모두 만족해야 한다. 완전성(completeness) : 어떤 조건이 참이라면 신뢰할 수 있는 검증자(honest verifier)는 신뢰할 수 있는 증명자(honest prover)에 의해 이 사실을 납득할 수 있어야 한다. 건전성(soundness) : 어떤 조건이 거짓이면 신뢰할 수 없는 증명자(dishonest prover)는 거짓말을 통해 검증자에게 조건이 참임을 절대 납득시킬 수 없다. 영지식성(zero-knowledge) : 어떤 조건이 참일 때, 검증자는 이 조건이 참이라는 사실 이외의 아무 정보를 알 수 없다. 동굴의 비유영지식증명의 3가지 조건인 완전성, 건전성, 영지식성을 만족시키는 사례임과 동시에 영지식 증명을 이해하기 쉬운 문제로 설명한 사례가 알리바바 동굴(Alibaba’s cave)의 비유이다. 장 자크 키스케다(Jean-Jacques Quisquater)는 〈어린이들을 위한 영지식증명〉이라는 논문에서 동굴의 비유를 들어 설명했다. 찰리(Charlie)는 증명자(prover)이고 스미스(Smith)는 검증자(verifier)라고 가정하자. 찰리와 스미스 모두 비밀문이 있는 동굴 가까이에 왔다. 둥근 고리 형태의 동굴에는 A와 B라는 길이 있으며 그 사이에는 도어락이 설치된 비밀문이 있다. 찰리는 스미스에게 비밀문의 암호를 알고 있다고 말했다. 하지만 찰리는 스미스를 포함한 다른 누구에게도 그 암호를 밝히고 싶지 않다. 이에 대해 스미스는 믿을 수 없다며 찰리에게 암호를 알고 있음을 증명하라고 한다. 즉, 검증자는 증명자에게 직접적으로 설치된 도어락의 비밀번호를 물어보지 않고 증명자가 비밀번호를 알고 있다는 명제가 참인지 확인하려 한다. 이 조건문이 참인지를 확인하기 위해 다음 방법을 사용할 수 있다. 증명자가 먼저 동굴에 들어간 다음, 도어락 근처로 이동한 후 검증자를 동굴 안으로 부른다. 검증자는 A와 B의 갈림길에 서서 증명자에게 특정 길로 나오라고 지시한다. 증명자는 검증자가 지시한 길로 나온다. 이 과정을 통해 증명자는 검증자에게 자신이 알고 있는 비밀번호를 알려주지 않고도 자신이 비밀번호를 알고 있음을 증명할 수 있다. 하지만 이 과정을 한 번만 보았을 때는 증명자가 비밀번호를 정말로 알고 있어서 검증자가 지시한 길로 나왔는지 확신하기 어렵다. 왜냐하면 증명자가 우연히 올바른 길로 나왔을 수도 있기 때문이다. 하지만 위 과정을 일정 횟수 이상 반복하여도 항상 증명자가 검증자의 지시대로 행동했다면 증명자는 검증자에게 자신이 비밀번호를 알고 있다는 사실을 납득시킬 수 있다. 예를 들어 위와 같이 20번만 반복해도, 증명자가 비밀번호를 모르면서도 검증자의 지시를 모두 따를 수 있는 확률은 100만분의 1 이하가 된다. 만약 이 과정을 40회 반복하게 되면, 우연히 비밀번호를 맞출 확률은 1조분의 1 이하가 된다. 이 과정을 영지식증명의 3가지 조건에 대입시키면 다음과 같다. 완전성(completeness) : 위 실험을 여러 번 수행하는 경우에도 증명자가 검증자의 지시를 계속 따르게 된다면 검증자는 증명자가 비밀번호를 안다고 납득할 수 있다. 건전성(soundness) : 증명자가 사실은 비밀번호를 모르지만 안다고 거짓말을 했을 경우 검증자에게 언젠가 한 번은 지시대로 수행하지 못하는 경우가 생기기 때문에 증명자가 비밀번호를 안다는 것을 증명할 수 없다. 영지식성(zero-knowledge) : 여러 번의 반복을 통해 검증자는 증명자가 비밀번호를 알고 있다는 사실을 납득했지만 비밀번호가 무엇인지는 알지 못한다. 이 실험에서 증명자는 오직 검증자에게만 자신이 비밀번호를 안다는 사실을 증명할 수 있다. 이 실험을 관찰하는 다른 제3자들은 증명자가 정말로 비밀번호를 알고 있는지 확신할 수가 없다. 왜냐하면 제3의 관찰자는 증명자와 검증자가 사전에 미리 짜고 그 순서대로 동굴의 문을 열고 나왔을 수도 있기 때문이다. 하지만 검증자는 자신이 정말로 랜덤하게 문을 지정했다는 사실을 알고 있기 때문에, 증명자가 비밀번호를 알고 있다고 확신할 수 있게 된다. 이처럼 영지식증명은 오직 해당 증명 과정에 참여한 증명자와 검증자만 사실을 확신할 수 있으며, 이 증명을 관찰하는 제3자는 증명자가 정말로 해당 내용을 알고 있는지 확신할 수 없게 만든다는 특징이 있다.","link":"/2021/12/27/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%95%94%ED%98%B8%ED%95%99-Hash-PKI-ECDSA-ZKP/"},{"title":"[Blockchain] 블록체인-스마트 컨트랙트","text":"스마트 컨트랙트스마트 계약 또는 스마트 컨트랙트(smart contract)는 계약 당사자가 사전에 협의한 내용을 미리 프로그래밍하여 전자 계약서 문서 안에 넣어두고, 이 계약 조건이 모두 충족되면 자동으로 계약 내용이 실행되도록 하는 시스템이다. 기존의 블록체인 1.0 기술이 ‘과거에 일어났던 일’을 기록한다면, 스마트 계약 기능을 구현한 블록체인 2.0 기술은 ‘미래에 일어날 일’을 미리 기록해 둘 수 있다. 스마트 컨트랙트는 중간에 제3의 보증기관을 끼우지 않고 개인간(P2P)에 원하는 계약을 체결할 수 있도록 해주는 디지털 전자계약 기능이다. 스마트 계약은 1994년 닉 재보(Nick Szabo)가 처음 제안하였으나 실제로 구현하지는 못하였다. 2013년 당시 19세의 비탈릭 부테린(Vitalik Buterin)은 스마트 계약 플랫폼인 이더리움(Ethereum)을 개발할 것을 제안하고, 2015년 7월 30일 이더리움 개발에 성공하여 실제 서비스를 시작했다. 솔리디티(solidity)라는 프로그래밍 언어를 사용하여, 계약 기간, 금액, 조건 등을 미리 코딩해 두면, 부동산 거래, 중고 자동차 거래, 무역 거래 등 어떠한 종류의 계약도 자동 실행되도록 만들 수 있다. 기존의 비트코인이 블록체인 기술을 활용하여 가치의 저장과 전달이 가능한 암호화폐를 만들었다면, 이더리움은 한 단계 더 나아가 블록체인 기술을 활용하여 인간이 상상할 수 있는 모든 종류의 계약을 자동으로 실행할 수 있는 스마트 계약 플랫폼을 개발했다. 비탈릭 부테린이 이더리움을 통해 스마트 계약 기능을 구현함으로써, 블록체인 기술을 비트코인과 같은 암호화폐에만 사용하는 것이 아니라, 위변조 방지가 필요한 각종 계약서 작성 등에 활용할 수 있게 되었다. 이런 점에서 기존의 비트코인을 ‘블록체인 1.0’이라고 부르고, 스마트 계약 기능을 구현한 이더리움을 ‘블록체인 2.0’이라고 부른 닉 재보의 비트골드스마트 계약은 1994년 닉 재보(Nick Szabo)가 처음 고안한 개념이다. 닉 재보는 스마트 계약을 “계약에 필요한 요소를 코드를 통해 스스로 실행되게 하는 전산화된 거래 약속”이라고 정의했다. 그는 스마트 계약이 자동판매기와 비슷하다고 말했다. 자동판매기에 미리 정해진 액수 이상의 돈을 투입하면, 자동으로 원하는 상품을 구매할 수 있듯이, 스마트 계약을 통해 일정한 조건이 충족되면 자동으로 계약이 실행되도록 한다는 것이다. 1996년 닉 재보는 스마트 계약 설계의 기본 원칙으로 관측 가능성, 검증 가능성, 사생활 보호, 강제 가능성 등 4가지를 제시했다. 관측 가능성(observability) : 스마트 계약은 서로의 계약 이행 가능성을 관찰하거나 성과를 입증할 수 있어야 한다. 검증 가능성(verifiability) : 계약을 이행 또는 위반했을 때 이를 알 수 있어야 한다. 사생활 보호(privacy) : 계약 내용은 계약에 관련된 당사자들에게만 알려져야 한다. 강제 가능성(enforceability) : 계약을 강제로 이행할 수 있는 구속력이 있어야 한다. 단, 강제 가능성은 최소화해야 한다. 닉 재보는 스마트 계약을 위해 비트골드(bit gold)라는 디지털 화폐를 고안했지만, 당시의 기술적 한계로 인해 실제로 개발되거나 사용되지는 못하였다. 하지만 닉 재보가 고안한 스마트 컨트랙트 개념은 이후 비트코인 스크립트로 이어졌고, 2015년 7월 30일 비탈릭 부테린(Vitalik Buterin)에 의해 이더리움(Ethereum)이 개발됨으로써 실제로 구현되었다. 비트코인 스크립트닉 재보는 스마트 계약을 위해 비트골드(2009년 1월 3일 사토시 나카모토(Satoshi Nakamoto)가 비트코인(Bitcoin)을 개발하고, 비트코인의 신뢰 보장 기술인 블록체인이 등장하자 스마트 컨트랙트가 다시 관심을 받으며 부상하기 시작했다. 기존 디지털 프로토콜의 낮은 신뢰성과 복제 및 위변조 문제로 인해 실제 구현되기 어려웠던 스마트 계약은 블록체인 기술을 통해 무결성을 보장하고 조작방지가 가능한 블록체인 기반 스마트 컨트랙트로 개발될 수 있게 되었다. 비트코인 프로토콜도 낮은 수준의 ‘스마트 계약’ 기능을 가지고 있다. 기술적인 관점에서 봤을 때, 비트코인의 장부는 하나의 상태변환 시스템(state transition system)으로 생각해볼 수 있다. 이 시스템은 현재 모든 비트코인의 소유권 현황으로 이루어진 하나의 상태(state)와 이 현재 상태 및 트랜잭션을 받아서 그 결과로서 새로운 상태를 출력해주는 상태변환함수(state transition function)로 구성되어 있다. 최초의 블록체인 기반 스마트 컨트랙트는 바로 비트코인 스크립트이다. 비트코인의 결제 시스템인 UTXO(사용되지 않은 트랜잭션 출력)은 간단한 스택 기반 프로그래밍 언어로 표현된 복잡한 스크립트에 의해서도 작동한다. UTXO(유티엑스오)는 ‘Unspent Transaction Outputs’의 약자로서, ‘미사용 트랜잭션 출력값’ 또는 ‘미지출 거래 출력’이라고 한다. 비트코인은 이더리움의 ‘계좌 잔고 모델’(account balance model)과 달리 계정이나 잔고가 없고, 블록체인에 기록된 “소비되지 않은 출력값”을 통해 거래의 유효성을 검사하여 코인의 존재 여부를 확인한다. 비트코인 트랜잭션에 원시 언어인 오피코드(OPCODE)로 스크립트를 작성해서 보내면, 조건에 따라 자동으로 거래를 수행할 수 있다. 하지만 비트코인 스크립트는 튜링 불완전 언어를 사용하고, 반복문(loop)은 사용할 수 없고, 다양한 상태를 표현할 수 없으며, 비트코인 잔고 외의 다른 정보를 관리할 수 없다는 한계가 있다. 만약 비트코인 스크립트에서 반복문을 허용할 경우, 스크립트 조건 때문에 코드 실행을 0부터 시작하는 프로그램 카운터를 하나씩 증가시키면서 반복적으로 연산을 수행하도록 구성된 무한루프가 발생하여 네트워크 전체가 멈출 수 있기 때문이다. 이더리움 스마트 컨트랙트이더리움은 비트코인 스크립트 시스템의 튜링 불완전성이라는 한계를 극복하고자 나온 스마트 컨트랙트 플랫폼(smart contract platform)이다. 비탈릭 부테린이 창시한 이더리움 블록체인의 경우, 블록에 데이터뿐만 아니라 비트코인 스크립트 시스템의 한계인 조건문(if), 반복구문(loop) 등의 실행 코드를 포함시켜 로직의 실행을 자동화할 수 있다. 스마트 컨트랙트를 구현하기 위한 컨트랙트 코드(contract code)는 이더리움 가상머신(EVM, Ethereum Virtual Machine)이라는 독립된 실행 환경에서 실행된다. 여기에 스마트 컨트랙트를 실행할 때마다 수수료인 가스(gas)를 발생시키고 네트워크상에 수수료의 한계를 설정하여 무한루프를 막았다. 무한히 반복되는 조건을 만들어 스마트 컨트랙트를 실행시키면 중간에 수수료 한계점에 도달하게 되는데, 이때 중단된다. 이더리움에서 스마트 컨트랙트는 솔리디티(Solidity) 언어로 프로그래밍된다. 솔리디티 언어로 프로그래밍된 스마트 컨트랙트는 컴파일러(solc)에 의해 바이트코드(bytecode)로 컴파일되고, 컴파일된 바이트코드는 블록에 포함되어, 이더리움 가상머신(EVM)에 의해 실행된다. 이더리움 가상머신(EVM)은 이더리움 스마트 컨트랙트의 바이트코드를 실행하는 32 바이트 스택 기반의 실행환경이다. 이더리움이 제공하려는 것은 튜링 완전(turing-complete) 프로그래밍 언어가 심어진 블록체인이다. 이 프로그래밍 언어는 코딩된 규칙에 따라 ‘어떤 상태’를 ‘다른 상태’로 변환시키는 기능(arbitrary state transition functions)이 포함된 계약을 사용자들이 직접 작성할 수 있게 함으로써, 인간이 상상할 수 있는 모든 종류의 계약을 스마트 컨트랙트로 만들 수 있다. 이를 통해 모든 계약이 자동으로 실행할 수 있고, 이를 위한 다양한 분산형 애플리케이션인 디앱(DApp)도 만들 수 있다. 누구든지 솔리디티 언어를 사용해 스마트 컨트랙트와 디앱을 작성하고 소유권에 대한 임의의 규칙, 트랜잭션 형식(transaction format), 상태변환함수(state transition function) 등을 생성할 수 있다. 초창기 이더리움 스마트 컨트랙트에서 가장 이슈가 되었던 예는 다오(DAO, Decentralized Autonomous Organization)라고 불리는 탈중앙화된 자율 조직이다. 다오(DAO)는 스마트 컨트랙트 기술로 구현된 조직으로 중앙의 운영 주체가 없이 개인들이 자율적으로 제안 및 투표를 하여 다수결로 의결하여 운영되는 조직이다. 회사의 의결권을 다오토큰(DAO Token)으로 행사할 수 있도록 크라우드 펀딩을 통해 이더리움으로 다오토큰을 살 수 있게 판매하였다. 이 과정에서 모인 약 2,000억원 가량의 이더리움을 어떻게 사용할지 다오토큰을 기반으로 투표할 수 있도록 했다.","link":"/2021/12/28/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EC%8A%A4%EB%A7%88%ED%8A%B8-%EC%BB%A8%ED%8A%B8%EB%9E%99%ED%8A%B8/"},{"title":"[Bitcoin] 비트코인 세그윗","text":"세그윗(SegWit)개요세그윗(SegWit, Segregated Witness)은 비트코인의 블록에서 디지털 서명 부분을 분리함으로써 블록당 저장 용량을 늘리는 소프트웨어 업그레이드를 말한다. 기존의 비트코인에서 서명 부분을 분리한 세그윗을 처음으로 활성화한 암호화폐는 그로스톨코인(Groestlcoin)이다. 2017년 8월 1일을 기준으로 전 세계 비트코인은 세그윗이라는 소프트포크(soft fork)를 진행하였다. 기존의 비트코인은 거래내역을 기록하는 블록 크기가 1MB에 불과하여 초당 7건, 하루 최대 60만건의 거래내역밖에 처리하지 못하는 한계가 있었다. 이 문제를 해결하기 위해 비트코인 블록에서 디지털 서명 부분을 분리하여 별도로 저장함으로써, 블록당 저장 용량을 늘릴 수 있게 되었다. 한편 세그윗을 진행할 경우 중국의 채굴업자들이 사용하던 에이식부스트(AsicBoost) 방식의 비트코인 채굴이 불가능해지게 된다. 이에 앤트풀(Antpool), 비아비티씨(viaBTC) 등 중국의 채굴업체들을 중심으로 기존 에이식(ASIC) 채굴기를 사용한 비트코인 채굴을 지속하기 위해 기존 비트코인 블록에서 분리된 비트코인캐시(BCH, Bitcoin Cash)라는 이름의 새로운 암호화폐를 생성했다. 중국의 오케이코인(OKCoin), 한국의 빗썸 등 주요 암호화폐 거래소들은 하드포크를 통해 기존 비트코인(BTC) 소유자들에게 비트코인캐시(BCH)를 1:1 비율로 무상 지급하는 에어드랍(airdrop)을 진행하였다. 배경비트코인은 2008년 처음 사토시 나카모토의 “peer to peer electronic cash system”에서 등장했고, 사토시는 블록의 크기를 제한했던 적은 없었다. 비트코인 개발에 큰 공헌을 한 할 피니(Hal Finney)는 사토시에게 블록의 크기를 제한하지 않으면, DDoS 같은 공격에 취약하다고 말하며 그에게 1MB의 블록 크기를 제안한다. 사토시는 이를 받아들여서 현재의 비트코인 블록 크기가 되었다. 비트코인의 관심이 없던 때에는 큰 문제가 발생하지 않았으나, 시간이 점차 흐르면서 사람들은 비트코인에 관해서 관심을 가지고 어느샌가 비트코인의 가격이 생각지도 못하게 큰 폭으로 오르게 된다. 2013년에는 비트코인의 거래량이 한 블록에 담지 못할 정도로 많아지게 되었고, 비트코인은 10분당 하나의 블록을 생성하며 하나의 블록에는 약 2,100개의 거래만 입력할 수 있게 되었기 때문에 거래가 빠르게 진행이 안 된다는 문제가 생기기 시작했다. 예를 들어, 10분 거래량이 1만 번 이상 생기게 되면, 최소 5번째 블록부터 확인을 받아서 거래를 처리하게 되고 1시간 이상을 기다려야 하는 문제가 생긴다. 시간이 흐르면서 이 부분에 대한 큰 개선이 없자 비트코인은 캐시 시스템 즉, 전자화폐의 개념보다는 가치를 저장하는 금(Gold)과 같은 모습으로 변질한다. 특징거래 속도의 확장성(scalability)비트코인은 현재 기술력으로 1초에 7개의 거래를 성사시킨다. 이는 master card와 같은 금융기관이 1초에 수백만 건의 거래를 처리할 수 있는 것에 비해 현저히 속도가 떨어지는 것이다. 이를 거래 속도의 확장성(scalability) 문제라고 하는데, 이 확장성 문제를 해결하지 못해 초당 7개의 거래를 처리한다면 전 세계 사람들이 이용하는 경우 하나의 거래를 처리하는 데 몇 년이 걸릴 수 있기 때문에 이를 반드시 해결하지 않고선 비트코인의 대중화는 어렵다. 이 확장성 문제를 해결하기 위해 세그윗을 사용한다. 거래하기 위해서는 거래를 하는 당사자의 서명이 필요하다. 서명은 신원을 증명하는 것인데, 디지털 서명은 서명을 컴퓨터상에서 숫자 등으로 암호화하여 만드는 것이다. 디지털 서명이란 돈을 보내는 사람의 개인 키로 암호화한 메세지들 돈을 받는 사람이 돈을 보내는 사람의 공개키로 해석하여 돈을 보내는 사람이 맞는지 신원을 확인하고 증명하는 것이다. 블록의 구조를 보면 디지털 서명란과 거래 내역이 하나로 뭉쳐 있다. 서명란에 서명이 실제로 차지하는 크기는 크지 않지만, 서명란 자체가 차지하는 부피가 크다. 이런 문제를 확장성 문제라고 하고 블록의 크기를 1MB 내외로 유지하면서 거래를 처리할 수 있는 속도를 더 빨리할 수 있는 방법이 세그윗이다. 세그윗은 서명 부분을 따로 Witness라는 데이터 영역으로 분리해 더 많은 거래를 처리할 수 있도록 업데이트하는 것이다. 단순히 블록의 크기를 키우는 것도 방법이 될 수 있지만 그것을 감당할 수 있는 해시파워가 전 세계적으로 많지 않아 탈중앙화라는 블록체인의 특성에 맞지 않게 된다. 따라서 블록 크기를 유지하면서 블록 내부의 내용을 업데이트하는 것이다. 거래 가변성(Transaction Malleability) 모든 비트코인 거래에는 해당 거래를 식별할 수 있는 거래의 ID(transaction ID : txid)를 포함한다. txid가 ‘ID’라면 txid를 따라다니는 전자서명은 ‘비밀번호’라고 할 수 있다. 거래 가변성은 실질적인 거래 내용에는 변화가 없지만, 거래 ID(txid)만 변경하여 새로운 거래를 만들어 낼 수 있는 일종의 버그를 말한다. 즉, 거래 ID는 한 사람에게 하나만 주어지는 것이 원칙이지만, 두 개 이상의 거래 ID로 서로 다른 거래처럼 보이지만 실제 거래 내역은 동일한 거래를 가질 수 있는 것이 가변성의 문제이다. 이런 거래 가변성 문제는 거래 내역을 검증하는 것이 노드들의 역할이어서 근본적 문제라고 할 수 없고, 신중하다면 일어나지 않는 문제이다. 하지만 발생했을 때 비트코인의 가치는 하락한다. 가변성의 문제를 세그윗이 이 txid를 따로 보관하고 관리함으로써 여러 개의 ID를 가지고 장난을 치거나 동일한 거래 내역 여러 개를 만드는 것을 막을 수 있다. 버전 호환세그윗은 하드 포크가 아닌 소프트포크이므로 비트코인 소프트웨어의 업그레이드를 하지 않아도 세그윗 이전과 세그윗 적용 버전을 모든 노드에서 사용할 수 있다. 세그윗 미적용 노드 비트코인 코어 기준 0.13.1 이전은 1MB 이상의 블록은 읽을 수 없다. 하지만 거래의 중요한 입출력 내용은 1MB 이내에 들어 있기 때문에 호환이 가능하다. 서명 부분이 빠져있기 때문에 구버전의 노드는 이를 검증하지 않고 그냥 받아들이지만, 세그윗이 가능한 버전의 노드들이 이를 증명해주기 때문에 문제가 되지 않는다. 요약","link":"/2021/12/30/%EB%B9%84%ED%8A%B8%EC%BD%94%EC%9D%B8-%EC%84%B8%EA%B7%B8%EC%9C%97/"},{"title":"[Solidity] 솔리디티, EVM, Opcode, Bytecode","text":"솔리디티솔리디티(Solidity)는 이더리움 등 블록체인 플랫폼에서 스마트 컨트랙트 작성과 구현에 사용되는 컨트랙트 지향 프로그래밍 언어이다. C++, 파이썬, 자바스크립트의 영향을 받은 고수준 언어이다. 이더리움 가상머신(Ethereum Virtual Machine)이라는 EVM을 타깃으로 디자인된 솔리디티는 이더리움 가상머신에서 작동 가능한 바이트코드로 컴파일된다. 솔리디티는 정적 타입(statically-typed)이고 여러 기능 중 상속, 라이브러리, 유저 정의 타입을 지원한다. 튜링완전이라는 특성을 가진 솔리디티는 반복문과 제어문을 사용할 수 있다. 솔리디티는 하나의 컨트랙트 내에서 다중 타입의 안전한 함수가 가능하게 하는 ‘응용 이진 인터페이스’(ABI; application binary interface)가 포함된다. 이더리움 가상머신이더리움 가상머신은 스마트 콘트랙트 배포 및 실행을 처리하는 이더리움의 일부다. 하나의 외부 소유 계정(External Owned Account)에서 다른 외부 소유 계정으로 간단한 값을 전송하는 트랜잭션은 이더리움 가상머신이 필요 없지만, 그 외 모든 것은 이더리움 가상머신에 의한 상태 업데이트를 수반한다. 크게 보면 이더리움 블록체인에서 실행되는 이더리움 가상머신은 자체 영구 데이터 저장소가 있는 수백만 개의 실행 가능 객체를 가진 전 세계에서 탈중앙화된 컴퓨터다. 이더리움 가상머신(EVM)을 통해 모든 노드들의 컴퓨터에서 동일한 연산을 수행함으로 동일한 상태(state)에 합의한다. 이더리움은 전 세계 모든 참가자가 동일한 하나의 컴퓨터를 돌리는 것과 같기 때문에 ‘세계 컴퓨터’(world computer)라고 불리기도 한다 스마트 콘트랙트 실행에 사용할 수 있는 가스양에 따라 모든 실행 프로세스가 유한개의 계산 단계로 제한된다는 것을 의미한다. 이더리움 가상머신은 메모리 내의 모든 값을 스택에 저장하는 스택 기반 아키텍처로 256비트의 단어 크기로 동작하며, 주소 지정이 가능한 여러 개의 데이터 구성 요소를 가지고 있다. 실행할 스마트 콘트랙트의 바이트 코드가 저장되는 불변 프로그램 코드 롬, 모든 위치가 0으로 초기화하는 파괴성 메모리, 이더리움 상태의 일부인 영구 저장소가 이에 해당한다. 이더리움 가상머신의 명령어 집합에는 산술 및 비트 논리 연산, 실행 콘트랙트 세트 조회, 스택, 메모리, 스토리지 접근, 흐름 제어 작업, 로깅, 호출, 기타연산자 등이 있다. Opcode이더리움 컨트랙트의 코드는 낮은 수준(low-level)의 스택 기반(stack-based) 바이트코드 언어로 작성되어 있다. 옵코드(Opcode)는 사람들이 읽기편한 형태의 낮은 수준의 명령어 이다. 모든 opcode는 해당하는 16진수 값을 갖는다. 예를 들어 “mstore“는 “0x52“, “sstore“는 “0x55“이다. 현재는 140개의 고유한 Opcode가 존재한다. BytecodeOpcode를 효율적으로 저장하고 EVM이 읽기 가능하게 만들려면 bytecode로 저장될 필요가 있다. 예를들어, 만약 0x6001600101이라는 bytecode가 있다. 이러한 bytecode는 1바이트 크기로 나누어 의미를 가진다. 첫번째 명령어인 Opcode의 0x60은 PUSH1으로 번역된다. PUSH1은 값을 스택에 저장하므로, [ 0x01 ]이 스택에 저장된다. 이렇게 스택에는 하나의 아이템이 저장되며 다음 명령어로 넘어가게 된다. 다음 명령어도 같은 0x6001이므로 스택에는 [ 0x01, 0x01 ]이 저장되어 있다. 마지막 명령어는 0x01이며 이는 ADD로 번역된다. 따라서 스택 안에 있는 두개의 데이터를 더해서 스택에 넣고, 최종 결과는 스택에 [ 0x02 ]가 저장 되어있다.","link":"/2022/01/04/%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-EVM-Opcode-Bytecode/"},{"title":"[Solidity] 난수","text":"원문으로 가기Credit: Zouheir Layine 이 포스트는 xtremetom가 작성한 Solidity — Random Numbers를 번역한 내용이며, 임의로 첨삭한 부분이 있습니다.모든 번역 포스트는 원작자의 동의를 받아 번역을 진행하였습니다. 시작하기 앞서, 순전히 온체인에서 난수를 생성하는 것이 불가능하다는 것을 아셨으면 합니다. 체인링크(chainlink)와 같은 서비스를 사용해야 하지만, 솔직히 말해서, 유사난수(pseudo-random)는 대부분의 상황에서 충분합니다. 하지만\u001b 때로는 여러 개의 난수가 필요하고 가스 측면에서 비용이 많이 들기 시작합니다. Byte Shifting바이트 조작(Byte manipulation)은 정말 재미있습니다. 아니면 제가 아주 잘 알려지지 않은 글에 너무 깊이 빠져들었던가, 둘중 어느 쪽이든 이것은 매우 유용하며 가스를 절약하는 데 사용할 수 있습니다. Byte Shifting이 뭔가요?이 주제 및 다른 바이트 조작 기술은 저보다 훨씬 똑똑하고 경험이 풍부한 사람들에 의해 다뤄졌습니다. Bitwise Operations and Bit Manipulation in Solidity, Ethereum RNG와 함께 Byte Shifting을 어떻게 사용하나요?자, RPG NFT의 속성에 대해 10개의 난수를 생성해야 한다고 상상해 보세요. 다음과 같이 만들 수 있습니다. 123function dirtyRNG() public returns(uint256) { return uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender))} 위의 코드의 문제는 난수를 생성할때 함수를열 번을 호출해야야 한다는 것입니다. 여기 좋은 해결책이 있습니다. 1234567891011121314151617181920uint256 maxStatValue = 100;function generateStats() public view returns(uint256[] memory){ // generate psuedo-randomHash uint256 randomHash = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender))); // build an array of predefined length uint256[] stats = new uint256[](10); // iterate over the number of stats we want a random number for for(uint256 i; i &lt; 10; i++){ // use random number to get number between 0 and maxStatValue stats[i] = randomHash % maxStatValue; // byte shift randomHash to the right 8 bytes - can be fewer randomHash &gt;&gt;= 8; } return stats;} 이것처럼 우리는 하나의 randomHash만 생성한 다음 바이트 조작을 사용하여 10개의 필요한 난수를 생성할수 있습니다. 이것은 byte shifting를 사용해 끈임없이 바이트 조작을 할수 있다는 것을 의미하는 것이 아니라, 바이트 조작을할 바이트가 부족해질 것이라는 점에 주목할 필요가 있습니다. 만약 uint256 변수가 있고 &gt;&gt; 16으로 byte shifting 을하는 경우 16 x 16 = 256이기 때문에 16번만 전환할 수 있습니다. 개인적으로 이러한 컨셉에 대한 시각적 설명이 있으면 이해하기 더 쉽다고 느꼈고, 이것을 통해 여러분들이 이해하는데 도움이 될 것이라고 생각합니다. 사용 가능한 데이터 이상으로 이동하면 다음과 같은 일이 발생합니다. 난수 추적때때로, 이미 선택한 숫자를 추적하면서 기존 목록에서\b 난수를 선택해야 하는 경우가 있습니다. 자바스크립트에서 이런 작업은 쉬운 일이지만, 하지만 솔리디티에서는 가스를 절약하기 위해 방법론에 대해 생각해봐야 합니다. 고정 개체수의 TokenId10,000개의 토큰이 있는 NFT 프로젝트가 있고 임의의 순서로 토큰을 발행하고 싶다고 상상해 보십시오. 대부분의 방법은 데이터를 많이 루핑(looping)하고 저장(storing)해야 하므로 비용이 많이 들고 가스 소모의 위험이 있습니다. 마법의 배열(Magical Arrays)이 메서드의 적절한 이름이 무엇인지 전혀 몰라서 그냥 마법의 배열이라고 부릅니다. :) 1234567891011121314151617181920212223242526uint256 constant MAX_POPULATION = 10;uint256[] ids = new uint256[](MAX_POPULATION);function pickId() public returns(uint256 id) { require(ids.length &gt; 0, &quot;no data left&quot;); // generate random hash and use it to pick a number between 0 and ids.length uint256 randomIndex = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender))) % ids.length; // use current index or grab an old one if (ids[randomIndex] != 0) { id = ids[randomIndex]; } else { id = randomIndex; } // fill array position with value if (ids[ids.length - 1] == 0) { ids[randomIndex] = ids.length - 1; } else { ids[randomIndex] = ids[ids.length - 1]; } // shrink ids array ids.pop();} MAX_POPULATION: 생성중인 NFT의 개체수 입니다. ids: 길이가 MAX_POPULATION과 같은 빈 배열입니다. MAX_POPULATION이 5이면 배열은 다음과 같습니다. 1[0,0,0,0,0] pickId()가 호출되면 randomIndex는 0과 배열의 길이 사이에서 생성됩니다. 이것은 배열의 길이를 줄이고 가능한 randomIndex의 범위를 의미하기 때문에 중요합니다. 다음 몇 줄의 코드에서 마법 같은 일이 일어나기 시작합니다. 최선을 다해 설명하겠습니다. 첫 번째 패스우리의 배열이 [0, 0, 0, 0, 0]임을 가정해보십시오. 길이는 5개 요소이지만 모든 요소는 0입니다. 약간 쓸모없게 느껴지나요? 멋진 점은 이것이 매우 유용하다는 것입니다. randomIndex 값이 2로 설정 되었다고 상상해보십시오. 배열에서 인덱스 2를 확인하고 값이 0임을 알 수 있으므로 id의 반환 값을 방금 확인한 인덱스 2로 설정합니다. 123[0, 0, 0, 0, 0][2] = 0id = 2 이제 id 값이 설정되었으므로 어레이를 편집하여 방금 발생한 상황을 반영하고 id가 손실되지 않도록 해야 합니다. 우리는 배열에 많은 것을 기대하고 있군요. 만약 우리가 randomIndex 의 값인 2를 수정하지 않는다면 정확히 동일한 값이 반환 될것입니다. 그리고 우리는 tokenId가 2인 두 개의 NFT를 원하지 않습니다. 이 문제를 해결하기 위해 배열의 마지막 요소가 0인지 확인합니다. 1if(ids[ids.length-1] == 0) 마지막 요소가 0과 같다면, ids[randomIndex]의 값을 마지막 배열 요소의 인덱스 값으로 바꿉니다. 배열의 모습은 아래와 같습니다. 12randomIndex = 2[0, 0, 4, 0, 0] 끝으로, 마지막 요소를 제거하여 배열을 축소해야 합니다. 결과적으로 배열은 이제 다음과 같이 보입니다. 1[0, 0, 4, 0] 두 번째 패스다음 id를 선택할 때 randomIndex 값은 또 다시 2로 설정됩니다. 이게 문제가 될 수 있을 것 같은데요, 맞죠? — 아니요! 우리는 이것을 해결했어요. 먼저 인덱스 2에 있는 배열의 값이 0인지 확인합니다. 우리는 그 값이 4임을 알 수 있습니다. 1[0, 0, 4, 0] 첫 번째 패스에서 인덱스 값은 0과 같으므로 randomIndex 값 2를 반환했습니다. 이번에는 값이 4이므로 4를 반환합니다. 첫 번째 패스와 마찬가지로 방금 일어난 일을 반영하도록 배열을 편집해야 합니다. 이제 배열이 다음과 같이 표시됩니다. 1[0, 0, 3] 세 번째 패스눈치 채셨습니까?, 이번에도 randomIndex는 또다시 2로 설정되었습니다. 이번에는 인덱스 2의 값이 3이므로 3을 반환하고 이벤트를 반영하도록 배열을 편집합니다. 이번에는 상황이 약간 다릅니다. 배열의 마지막 값은 0이 아니므로 약간 다르게 작업을 수행해야 하며 결과 배열은 다음과 같이 됩니다. 1[0, 0] 마법 배열(Magic Array)이 방법이 이해하기 좀 어려울 수 있다는 것을 알고 있습니다. 저는 처음으로 이 방법을 사용했을 때는 개념을 완전히 이해했는지 확인하기 위해 종이에 배열을 매핑했습니다. 크리스마스 티저(Christmas Teaser)위의 마법 배열 코드 샘플을 최적화할 수 있습니다. 방법을 아시나요? 어디서 저를 찾을 수 있죠?저는 일반적으로 Cool Cats discord 채널에서 찾을 수 있습니다https://discord.gg/WhBAAHnSz4 또는 Twitterhttps://twitter.com/xtremetom https://twitter.com/coolcatsnft 마지막 으로이런 말을 하는 게 바보 같지만, 메시지를 너무 많이 받아서 당신과 제 시간을 절약할 수 있을 것 같아요. 저는 Cool Cats에서 풀타임으로 일하고 있습니다. 일이 너무 많아서 슬프게도 모든 일자리 제안을 거절해야 합니다. 하지만 저는 항상 제가 할 수 있는 한 자원과 조언을 공유하여 기꺼이 도와드리겠습니다.","link":"/2022/01/06/%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-%EB%82%9C%EC%88%98/"},{"title":"[Solidity]솔리디티 보안 재진입성(Reentrancy)","text":"원문으로 가기 Credit: Zuhaib Mohammed 이 포스트는 Zuhaib Mohammed가 작성한 Reentrancy | Hack Solidity #1를 번역한 내용이며, 임의로 첨삭한 부분이 있습니다. 모든 번역 포스트는 원작자의 동의를 받아 번역을 진행하였습니다. 이 글을 쓰게된 계기는 스마트 컨트랙트의 일반적인 취약점들을 알아보려고 노력한 것입니다. 이 여정을 도와준 Smart Contract Programmer에게 감사드립니다. 그의 채널도 확인해 주세요. 그럼 시작 합니다! Ethereum Classic의 탄생으로 이어지는 유명한 DAO 공격(DAO attack)에 대해 들어보셨을 것입니다. 공격자가 악용한 취약점을 “재진입(Reentrancy)“이라고 합니다. 재진입 공격이란?컨트랙트 A가 컨트랙트 B를 호출하는 두 개의 컨트랙트 A와 B가 있다고 가정합니다. 이 공격에서 발생하는 일은 첫 번째 호출이 아직 실행 중일 때 컨트랙트 B가 컨트랙트 A를 호출하고 일종의 루프가 발생한다는 것입니다. 우리는 아래 주어진 예시를 통해 공격을 더 잘 이해하려고 노력할 것입니다. 우리는 EtherStore라는 스마트 컨트랙트을 가지고 있으며 스마트 컨트랙트의 현재 잔액을 입금(deposit), 출금(withdraw) 및 확인(\bgetBalance)할 수 있습니다. withdraw 함수는 사용자가 가지고 있는 금액보다 더 많은 금액을 인출하지 못하도록 하는 체크 기능이 있지만 버그는 라인 16에 있습니다. 스마트 컨트랙트 주소로 이더를 보낼 때마다 fallback 함수라고 하는 것을 정의합니다. 대부분의 경우 이 기능은 빈 함수에 불과하지만 공격자가 충분히 실제 익스플로잇(exploit) 코드를 배치할수 있는 위치입니다. 공격공격자는 EtherStore 컨트랙트에서 라인 14에 대한 체크를 통과하기 위해 EtherStore 컨트랙트에 1 이더를 예치하는 익스플로잇(exploit) 함수를 호출합니다. 코드가 라인 16에 도달하면 공격자가 자금을 소진할 때까지 EtherStore에서 인출 함수를 호출하는 공격자 컨트랙트의 fallback 함수가 실행됩니다. 해결책이 공격이 가능한 이유는 EtherStore 컨트랙트에서 인출된 금액을 빼는 EtherStore 컨트랙트의 라인 20에 코드가 도달하지 않기 때문입니다. 이 문제를 해결하기 위해 두 가지 솔루션이 있습니다. 첫 번째는 사용자에게서 잔액을 빼기 위한 로직의 재배치입니다. 두 번째 해결책은 실행 중에 컨트랙트을 잠그고 실행이 끝나면 잠금을 해제하는 noReentrancy guard modifer를 사용하는 것입니다. 간단하게 실제 사례를 사용하여 문제를 설명하려고 노력 했습니다. 즐겁게 읽으셨기를 바랍니다. 챠오!!!","link":"/2022/01/11/%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-%EB%B3%B4%EC%95%88-%EC%9E%AC%EC%A7%84%EC%9E%85%EC%84%B1-Reentrancy/"},{"title":"[Solidity]솔리디티 보안 오버플로, 언더플로(Overflow and Underflow)","text":"원문으로 가기 Credit: Zuhaib Mohammed 이 포스트는 Zuhaib Mohammed가 작성한 Arithmetic Overflow and Underflow | Hack Solidity #2를 번역한 내용이며, 임의로 첨삭한 부분이 있습니다. 모든 번역 포스트는 원작자의 동의를 받아 번역을 진행하였습니다. 정수 오버플로와 언더플로의 기본 개념을 이해하기위해 제가 이전에 쓴 글을 한번 읽어보기를 추천합니다. TimeLock 컨트랙트의 예를 통해 이것을 더 잘 이해합시다. 컨트랙트에는 컨트랙트에 자금을 입금하는 기능이 있지만 사용자는 일주일이 지난 후에야 자금을 인출할 수 있습니다. 또한, increaseLockTime 함수를 통해 timeLock 주기를 늘리는 기능도 있습니다. 공격사용자의 자금 잠금 기간은 lockTime 배열에 저장됩니다. 공격자는 기본적으로 라인 19(현재 사용자의 lockTime 기간 확인)의 조건을 우회해야 합니다. 공격자의 컨트랙트를 살펴보고 이를 달성하는 방법을 알아보도록 하겠습니다. 공격자는 attack 함수로 ETH 일부를 컨트랙트에 예치하고 정수 언더플로우를 유발하는 increaseLockTime 함수를 호출합니다. 라인 48을 보면, lockTime 배열에서 현재 타임스탬프 값을 빼고 있으며, 실행 후 값이 0이 됩니다. 그리고 이제 당신은 아무런 제한 없이 당신의 자금을 인출할 수 있습니다. 122**256 = type(uint).max + 1 = 0 //due to integer Overflowtype(uint).max + 1 - timeLock.lockTime(address(this)) 해결책솔리드 0.8은 기본적으로 오버플로/언더플로에 대한 오류를 발생시키지만 이전 솔리드 버전을 사용하는 경우 OpenZeppelin의 Safemath.sol 라이브러리를 사용하면 오버플로가 발생할 경우 기본적으로 오류가 발생합니다. 즐겁게 읽으셨기를 바랍니다. 챠오!!!","link":"/2022/01/12/%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-%EB%B3%B4%EC%95%88-%EC%98%A4%EB%B2%84%ED%94%8C%EB%A1%9C-%EC%96%B8%EB%8D%94%ED%94%8C%EB%A1%9C/"},{"title":"[Solidity]솔리디티 보안 셀프디스트럭트(selfdestruct)","text":"원문으로 가기 Credit: Zuhaib Mohammed 이 포스트는 Zuhaib Mohammed가 작성한 selfdestruct | Hack Solidity #3를 번역한 내용이며, 임의로 첨삭한 부분이 있습니다. 모든 번역 포스트는 원작자의 동의를 받아 번역을 진행하였습니다. 스마트 컨트랙트 개발자라면 스마트 컨트랙트에 ETH를 보내려면 fallback 함수가 있어야 한다는 사실을 알고 있을 겁니다. 하지만 이번 해킹에서는 우리는 selfdestruct 함수를 호출 하여 스마트 컨트랙트에 ether를 강제로 보내는 방법을 배웁니다. selfdestruct는 무엇을 하나요?selfdestruct 함수는 블록체인에서 스마트 컨트랙트의 인스턴스를 삭제하고 그 전에 스마트 컨트랙트에 저장된 모든 나머지 ETH를 인수(argument)로 전달된 주소로 모두 전송합니다. 아래에 예시가 있습니다. 1selfdestruct(&quot;address_to_send_ETH_before_deletion&quot;); 게임EtherGame 컨트랙트는 각 사용자가 1개의 이더(ether)를 예치할 수 있는 매우 간단한 게임이며, 이더를 예치한 7번째 사람이 컨트랙트에 저장된 모든 이더를 얻습니다. 일단 (잔액 ≤ 목표 금액)을 만족하면, 더 이상 이더를 보낼 수 없으며 트랜잭션은 revert된다. 아래에서 EtherGame의 소스 코드를 볼 수 있습니다. 악의적인 공격자는 컨트랙트를 통해 selfdestruct 함수를 호출하고 ETH를 EtherGame 컨트랙트에 강제로 보내고 이를 망가트릴수 있습니다. 첫 번째 사용자 Bob이 1개의 ether를 보내고 두 번째 사용자 Alice가 1개의 이더를 보낸다고 상상해 보십시오. EtherGame 컨트랙트의 현재 잔액은 2 이더입니다. 이제 Eve는 아래 표시된 Attack 컨트랙트를 통해 selfdestruct 함수를 호출하고 EtherGame 컨트랙트에 5 이더를 보냅니다. EtherGame 컨트랙트의 잔액은 7 이더로 업데이트되었지만 승자는 설정되지 않았습니다. 그후 EtherGame의 라인 11에 정의된 조건으로 인해 이 다음으로 호출되는 deposit함수의 트랜잭션은 모두 revert될 것입니다. 이로서 아무도 EtherGame에 예치된 ETH를 가져갈수 없습니다! 해결책이를 방지하는 가장 좋은 방법은 address(this.balance)를 사용하여 컨트랙트의 현재 잔액을 업데이트하지 않고 로컬 상태 변수(balance)를 사용하여 사용자가 자금을 입금할 때에만 업데이트하는 것입니다. 공격자는 여전히 selfdestruct 통해 ETH를 보낼수 있지만, 게임을 망가트릴수는 없습니다. 재미있게 읽으셨기를 바랍니다. 챠오!!!","link":"/2022/01/13/%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-%EB%B3%B4%EC%95%88-%EC%85%80%ED%94%84%EB%94%94%EC%8A%A4%ED%8A%B8%EB%9F%AD%ED%8A%B8-selfdestruct/"},{"title":"[Solidity]솔리디티 보안 프라이빗 데이터 접근(Accessing Private Data)","text":"원문으로 가기 Credit: Zuhaib Mohammed 이 포스트는 Zuhaib Mohammed가 작성한 Accessing Private Data| Hack Solidity #4를 번역한 내용이며, 임의로 첨삭한 부분이 있습니다. 모든 번역 포스트는 원작자의 동의를 받아 번역을 진행하였습니다. 시작하기 전에 상태 변수(state variable)의 스토리지(storage)가 슬롯(Slot)을 통해 솔리디티에서 어떻게 작동하는지 이해해야 합니다. 제가 설명할 개념을 이해하는 데 어려움이 있는 경우 Smart Contract Programmer의 비디오를 참고하실수 있습니다. 슬롯 시스템솔리디티는 슬롯을 통해 컨트랙트에 정의된 변수를 저장합니다. 각 슬롯은 최대 32바이트 또는 256비트를 저장할 수 있습니다. 아래 이미지를 보면 변수 foo, bar 및 num은 크기가 256비트와 동일하기 때문에 전체 슬롯을 차지합니다. 어드레스(address)는 최대 20바이트를 차지하며 불리언(boolean)은 1바이트가 필요합니다. 여러 변수가 동일한 슬롯 인덱스에 채워지면 오른쪽에서 왼쪽으로 채워집니다. 접근 지정자(프라이빗)블록체인 기반 어플리케이션(dApp)의 코드를 작성할 때 변수를 공개 또는 비공개로 정의할 수 있습니다. 변수를 프라이빗으로 정의하는 목적은 다른 컨트랙트에서 변수를 수정하는 것을 방지하는 것입니다. 그러나 블록체인은 투명해야 합니다. 즉, 변수가 비공개 또는 공개인지에 관계없이 모든 사람이 읽을 수 있습니다. 따라서 비밀번호와 같은 민감한 정보를 저장하는 것은 매우 좋지 않은 생각입니다. 예제를 통한 이해Vault 컨트랙트에는 다양한 종류의 변수가 정의되어 있지만 가장 흥미로운 bytes32 password 그리고 id와 password를 저장하고 있는 struct Users의 배열입니다. addUsers 함수는 추가 사용자를 Users 구조(struct) 배열로 푸시합니다. 이 컨트랙트는 이미 Ropsten TestNet에 “0x3505a02BCDFbb225988161a95528bfDb279faD6b“주소로 배포되어 있습니다. 트러플(Truffle)을 사용하여 슬롯과 상호 작용하는 방법을 배우고 마지막으로 암호를 추출해 보겠습니다. 트러플 예제Ropsten에 연결하여 가지고 있는 컨트랙 주소로 초기화해 보겠습니다. 위 컨트랙트를 보시면 어떤 슬롯에 어떤 변수가 저장되어 있는지 이미 표시해 두었습니다. 12//Syntax to access the data stored in the slotsweb3.eth.getStorageAt(contractAddress, slotIndex, console.log) 아래 예에서는 slotIndex=0에서 데이터를 읽은 다음 16진수에서 10진수로 변환합니다. 이번에는 slotIndex=2, 즉 암호 변수의 내용을 읽으려고 합니다. 결과물은 bytes32이며 web3.utils.toAscii 함수를 통해 Ascii로 변환할 수 있습니다. 마지막으로 사용자 ID 및 암호를 읽을 시간입니다. 첫 번째 getStorageAt 호출은 배열 길이를 출력합니다. soliditySha3은 첫 번째 배열 요소의 스토리지 해시를 반환합니다. 다음 스토리지 아이템에 액세스하려면. 해시 값을 1 증가시켜야 합니다. 즉, 3f — &gt;40. 그 이면에 있는 논리에 대해서는 잘 모르겠습니다. 당신이 이것을 알고 있다면 나에게 꼭 알려주세요. 이것에 대한 조사를 하는 대로 업데이트하겠습니다. 해결책블록체인은 기본적으로 투명하므로 블록체인에 민감한 정보를 저장하지 마십시오. 즐겁게 읽으셨기를 바랍니다. 챠오!!!","link":"/2022/01/16/%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-%EB%B3%B4%EC%95%88-%ED%94%84%EB%9D%BC%EC%9D%B4%EB%B9%97%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%A0%91%EA%B7%BC/"},{"title":"[Solidity]솔리디티 보안 Unsafe Delegatecall | Part 1","text":"원문으로 가기 Credit: Zuhaib Mohammed 이 포스트는 Zuhaib Mohammed가 작성한 Unsafe Delegatecall (Part #1) | Hack Solidity #5를 번역한 내용이며, 임의로 첨삭한 부분이 있습니다. 모든 번역 포스트는 원작자의 동의를 받아 번역을 진행하였습니다. delegatecall 이란?컨트랙트A가 delegatecall을 사용하여 컨트랙트B를 호출하면 기본적으로 컨트랙트B에 해당 컨텍스트(storage, msg.sender, msg.value, msg.data 등) 내에서 컨트랙트A의 코드를 실행하도록 지시합니다. 스토리지 레이아웃은 컨트랙트A와 컨트랙트B에 대해 동일해야 합니다. 즉, 동일한 상태 변수가 동일한 순서로 선언되어야 함을 의미합니다. 예제를 통한 이해생성자 호출 중에 소유자가 설정되는 HackMe 컨트랙트가 있습니다. Lib 컨트랙트를 통해 delegatecall을 만드는 fallback 함수가 정의되어 있습니다. 우리는 소유자를 설정하는 Lib 컨트랙트에서 pwn 함수가 정의되어 있는 것을 볼 수 있습니다. 공격HackMe 컨트랙트의 소유자를 업데이트하기 위해, 악성 컨트랙트(Attack)로 부터 abi.encodeWithSignature(“pwn()”)를 통해 pwn 함수의 함수 시그니처(signature)를 전달합니다. 먼저, HackMe 컨트랙트에서 pwn 함수에 대한 조회가 발생합니다. Attack 컨트랙트에는 pwn 함수가 없기 때문에 pwn 함수의 시그니처로 Lib 컨트랙트를 호출하는 HackMe의 fallback 함수가 트리거됩니다. Lib 컨트랙트에 pwn 함수 정의가 있고 소유자가 msg.sender로 설정되어 있음을 알 수 있습니다. context-preservation에 의해 msg.sender가 이제 HackMe 컨트랙트의 소유자가 됩니다. 이 포스트의 2부에서 이를 방지하는 방법에대해 논의하겠습니다. 즐겁게 읽으셨기를 바랍니다. 챠오!!!","link":"/2022/01/18/%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-%EB%B3%B4%EC%95%88-Unsafe-Delegatecall-part1/"},{"title":"[Solidity]솔리디티 보안 Unsafe Delegatecall | Part 2","text":"원문으로 가기 Credit: Zuhaib Mohammed 이 포스트는 Zuhaib Mohammed가 작성한 Unsafe Delegatecall (Part #2) | Hack Solidity #5를 번역한 내용이며, 임의로 첨삭한 부분이 있습니다. 모든 번역 포스트는 원작자의 동의를 받아 번역을 진행하였습니다. 상태 변수가 잘못된 순서로 선언되거나 컨트랙에서 잘못된 데이터 타입으로 선언되면 어떻게 되는지 살펴보겠습니다. Unsafe Delegation Call의 Part #1을 읽지 않았다면 먼저 확인해주십시오. 공격Lib와 HackMe의 두 가지 컨트랙트가 있습니다. 우리의 목표는 HackMe 컨트랙트의 소유자를 악의적인 공격자로 업데이트하는 것입니다. HackMe 컨트랙트에서 doSomething을 통해 Lib 컨트랙트에 delegatecall이 수행되는 것을 볼 수 있습니다. 여기서 someNumber는 업데이트됩니다. 그러나 우리는 이미 delegatecall의 경우 상태 변수가 같은 순서로 선언되어야 한다는 것을 알고 있습니다. 따라서 HackMe 컨트랙트의 someNumber 대신 lib 변수가 업데이트됩니다. address 데이터타입은 20바이트를, uint는 32바이트를 가질수 있습니다. 따라서 공격자는 doSomething을 호출하기 전에 암시적 변환(implicit conversion)을 사용하고 lib 값을 공격자의 컨트랙트 주소로 업데이트합니다. 이제 공격자가 doSomething 함수를 두 번째로 호출하면, 그 호출을 공격자가 HackMe 주소의 소유자를 업데이트할 수 있는 공격자 컨트랙트 doSomething 함수에 위임(delegate)합니다. 참고: 공격자의 컨트랙트 상태 변수는 HackMe 컨트랙트와 동일한 순서를 따릅니다. 또한 공격자 컨트랙트의 doSomething 시그니처(signature)는 HackMe의 doSomething 시그니처와 일치해야 합니다(즉, 동일한 함수 이름 및 인수(argument)). 예방법delegatecall을 사용하는 동안 공격자에게 공격 표면(attack surface)을 제공할 수 있는 다른 상태 변수에 대한 불필요한 업데이트를 방지하기 위해 상태 변수가 동일한 순서로 선언되었는지 확인하십시오. 즐겁게 읽으셨기를 바랍니다. 챠오!!!","link":"/2022/01/19/%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-%EB%B3%B4%EC%95%88-Unsafe-Delegatecall-part2/"},{"title":"[Solidity]솔리디티 보안 랜덤성의 안전하지 않은 소스","text":"원문으로 가기 Credit: Zuhaib Mohammed 이 포스트는 Zuhaib Mohammed가 작성한 Insecure Source of Randomness| Hack Solidity #6를 번역한 내용이며, 임의로 첨삭한 부분이 있습니다. 모든 번역 포스트는 원작자의 동의를 받아 번역을 진행하였습니다. web2 기반 앱용 자바스크립트를 통해 난수를 생성하는 것은 간단합니다. 그러나 스마트 컨트랙트에서는 복잡합니다. 블록 해시, 블록 타임스탬프와 같이 사용할 수 있는 전역 변수가 있습니다. 우리는 충분히 무작위라고 생각하지만 사실이 아닙니다. 예제GuesTheRandomNumber 컨트랙트는 당첨자가 숫자를 정확히 맞히면 1 이더를 어카운트(account)에 얻는 게임을 호스팅합니다. guess 함수를 보면 답에 저장된 값이 블록 해시와 블록 번호를 사용하여 계산되어 충분히 랜덤한 것 같습니다. 그러나 공격자는 코드를 복사하고 자신의 컨트랙트를 통해 keccak256 해시를 계산한 다음 그 결과를 GuesTheRandomNumber 컨트랙트로 보낼 수 있습니다. 현재 블록이 아직 채굴되지 않았기 때문에 이전 블록의 블록해시를 계산하고 있으며 block.timestamp는 현재 트랜잭션이 블록에 포함될 타임스탬프 값을 얻습니다. 이 이벤트는 나중에 발생하므로 이 트랜잭션이 블록에 포함될 때까지 값이 무엇인지 알 수 없습니다. 우리의 해킹에서 해시 값을 미리 계산하고 거의 동시에 guessTheRandomNumber의 guess 함수를 호출합니다. 따라서 우리는 숫자를 정확하게 추측하는 데 성공합니다. 예방법 blockhash, block.timestamp, 또는 block.diffculty를 난수를 생성하기 위해 쓰지 마십시오. Chainlink의 VRF를 사용하여 변조 방지 온체인(tamper-resistant on-chain) 난수를 생성할 수 있습니다. 즐겁게 읽으셨기를 바랍니다. 챠오!!!","link":"/2022/01/20/%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-%EB%B3%B4%EC%95%88-%EB%9E%9C%EB%8D%A4%EC%84%B1%EC%9D%98-%EC%95%88%EC%A0%84%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EC%86%8C%EC%8A%A4/"},{"title":"[Clean Code]클린코드 1장 깨끗한 코드","text":"1장 깨끗한 코드🔖 읽은 범위 : 시작 ~ 1장, 깨끗한 코드 💭 기억에 남는것나쁜 코드 성능이 나쁜 코드 의미가 모호한 코드 중복된 코드 이리저리 불필요한 코드가 들어 있는 코드는 누가 봐도 나쁜 코드일 것이다. 또한 의미가 모호한 코드 예를 들어 네이밍과 맞지 않으면 보는 이들이 예상한 바와 다르고 이해하기 어려움을 겪을 것이다. 마지막으로 비슷한 내용인 중복되는 코드들은 버그를 일으키기 쉽기 때문에 나쁜 코드라고 할 수 있다. 나쁜 코드는 왜 나쁠까?필자는 깨진 유리창 법칙을 비유로 이 문제에 대해 재치있게 풀어냈다. 깨진 유리창 법칙이란, 깨진 유리창을 방치하면 그 지점을 중심으로 범죄가 확산하기 쉽다는 이론이다. 이러한 관점이 코드에서 적용이 될수도 있다. 나쁜 코드는 깨진 유리창 처럼 계속 해서 나쁜 코드를 유발하기 때문이다. 나쁜 코드를 보았을때 이것을 개선 하려는 노력없이 계속 해서 나쁜 코드를 작성하게 된다. 나쁜 코드가 나쁜 코드를 야기하는 악순환의 반복 인 것이다. 또한, 나쁜 코드가 쌓일수록 기술부채가 쌓이기 때문에 프로젝트 초기와 비교해서 생산성이 극도로 줄어 든다. 결국 생산성이 새로운 요구 사항을 따라 가지 못한다면, 하는수 없이 새로운 시스템을 만들어야한다. 하지만 기존의 서비스와 현재의 시스템을 유지보수하면서 새로운 시스템을 만드는것은 매우 힘든 일이다. 클린 코드아래는 책에서 여러 사람들이 생각하는 클린코드중 내가 개인적으로 마음에 드는 문구를 몇 가지 옮겼다. 깨끗한 코드는 한 가지를 제대로 한다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 성능이 좋은 코드, 의미가 명확한 코드(가독성이 좋은 코드), 중복이 제거된 코드. 즉, 나쁜 코드와 완전히 반대 되는 내용이다. 🤔 소감책의 저자는 1장에서 왜 클린 코드가 필요한지에 대해 알기 쉽게 소개를 하고 있다. 그의 주장은 재치 있으면서도 뼈대가 있다. 필요하다면 비유를 아끼지 않으며 다른 사람들의 말을 인용하기도 한다. 무엇보다 자신의 지식과 철학에 대해 자부심을 가지고 있으며, 그렇다고 자신과 다른 의견을 가진 자들에 대해 편협한 시각을 가지고 있지 않다. 서로 각 분야의 전문가이며 각자의 시각을 이해하고 존중하는 문화를 가지자고 말하는 저자의 주장은 매우 동감하며, 다시 한번 벼는 익을수록 고개를 숙인다는 말이 다시 한번 와 닿았다. 📖 3줄 요약 깨끗한 코드는 한가지에 ‘집중’ 한다. 깨끗한 코드는 나쁜 코드를 피하기 위해 짜는 것이다. 보이스카우트 룰 - 전보다 더 깨끗한 코드로 만든다","link":"/2022/01/30/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-1%EC%9E%A5-%EA%B9%A8%EB%81%97%ED%95%9C-%EC%BD%94%EB%93%9C/"},{"title":"[Solidity]솔리디티 보안 서비스 거부 공격(Denial of Service)","text":"원문으로 가기 Credit: Zuhaib Mohammed 이 포스트는 Zuhaib Mohammed가 작성한 Denial of Service | Hack Solidity #7를 번역한 내용이며, 임의로 첨삭한 부분이 있습니다. 모든 번역 포스트는 원작자의 동의를 받아 번역을 진행하였습니다. 이번 해킹에서 우리는 스마트 컨트랙트에서 서비스 거부 공격(Denial of Service)을 수행하는 방법을 배울 것입니다. 이 해킹의 기본 아이디어는 fallback 함수를 정의하지 않음으로써, 전송되는 이더를 거부하고 트랜잭션이 성공한 경우 나머지 로직이 실행되지 않도록 하는 것이다. 예제아래는 KingOfEther 컨트랙트 입니다. 왕이 되기 위해 각 사용자는 이전 사용자보다 더 많은 이더를 입금해야 하는 게임입니다. 악의적인 공격자는 fallback 함수가 없이 Attack 컨트랙트를 정의합니다. 따라서 공격자가 왕이 된 후 사용자가 만든 Attack 컨트랙트에 이더를 보내려는 호출은 실패하고 상태를 되돌립니다. 일단 공격자가 왕이 되면, 11행의 조건은 항상 실패하므로 claimThrone 호출에 대한 후속 요청은 14행에 도달하지 않습니다. 그 결과, 공격자는 게임을 완전히 중단시키고, 어떠한 새로운 유저도 입금하여 왕이 될 수 없다. 예방법아래 주어진 솔루션에서 우리는 각 사용자의 자금에 대한 잔액 매핑을 유지하고 claimThrone 호출에서 업데이트합니다. 새 사용자에 의해 폐위된 사용자는 withdraw 함수를 호출하고(그는 왕이 아니어야 함 — 18행) 자금을 이체할 수 있습니다. 자금 인출 여부와 관계없이 게임은 계속되며 자금을 인출하지 않은 사용자의 잔액은 잔액 매핑에서 유지됩니다. 즐겁게 읽으셨기를 바랍니다. 챠오!!!","link":"/2022/01/22/%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-%EB%B3%B4%EC%95%88-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B1%B0%EB%B6%80-%EA%B3%B5%EA%B2%A9/"},{"title":"[Solidity]솔리디티 보안 tx.origin을 사용한 피싱","text":"원문으로 가기 Credit: Zuhaib Mohammed 이 포스트는 Zuhaib Mohammed가 작성한 Phishing with tx.origin | Hack Solidity #8를 번역한 내용이며, 임의로 첨삭한 부분이 있습니다. 모든 번역 포스트는 원작자의 동의를 받아 번역을 진행하였습니다. tx.origin vs msg.sender컨트랙트A가 컨트랙트B를 부르고 컨트랙트B가 컨트랙트C를 호출하는 예를 들어보자. tx.origin의 값은 address(컨트랙트A)이고 msg.sender의 값은 address(컨트랙트B)이다. 12ContractA -&gt; ContractB -&gt; ContractC{tx.origin = address(컨트랙트A), msg.sender = address(컨트랙트B)} 이는 tx.origin이 트랜잭션이 시작된 주소를 추적하고 msg.sender가 이를 호출한 계정 또는 컨트랙트의 주소를 보유하기 때문입니다. 예제아래는 소유자가 컨트랙트를 배포한 사람으로 설정된 Wallet 컨트랙트를 볼 수 있습니다(예: alice.eth). 소유자가 아무 계정에 이더를 보낼 수 있는 transfer 함수가 있습니다. 공격자가 자신의 계정으로 일부 이더를 전송하기 위해 호출하려는 경우 11행의 조건을 전달해야 합니다. tx.origin과 msg.sender의 차이점을 어느 정도 이해하셨기를 바랍니다. 이전에 작성한 글에 이것에 대해 전에 설명을 하였습니다. 이제 다시 문제로 돌아갑니다. 해커는 Attack 컨트랙트에서 attack 함수를 정의합니다. 해커가 스스로 공격 기능을 발동시키면 그 transaction 실패할 것입니다. 공격이 성공하려면 해커가 어떻게든 alice.eth(소유자)를 유인하여 attack 함수를 트리거하도록 해야 합니다. tx.origin == owner인 이유는 alice.eth가 attack 함수를 트리거한 사람이고 해커의 계정으로 자금이 이체되었기 때문입니다. 해결책tx.origin 대신 msg.sender를 사용하세요. 그게 전부 입니다! 즐겁게 읽으셨기를 바랍니다. 챠오!!!","link":"/2022/01/23/%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-%EB%B3%B4%EC%95%88-tx-origin%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%ED%94%BC%EC%8B%B1/"},{"title":"[Clean Code]클린코드 2장 의미있는 이름","text":"2장 의미있는 이름🔖 읽은 범위 : 1장, 깨끗한 코드 ~ 2장, 의미있는 이름 💭 기억에 남는것 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용해서는 안된다. ex) hp, aix, sco 흡사한 이름을 사용하지 않도록 한다. XYZControllerForEfficientHandlingOfStrings vs XYZControllerForEfficientStorageOfStrings 일관성이 떨어지는 표기법은 그릇된 정보이다. 연속된 숫자를 덧붙이거나 불용어(noise word)를 추가 하는 방식은 적적하지 못하다. a1, a2, a3, a4, …, aN 읽는 사람이 차이를 알도록 이름을 지어라 customerInfo vs customer 발음하기 쉬운 이름을 선택한다 genymdhms -&gt; generationTimeStamp 클래스 이름과 객체 이름은 명사나 명사구가 적합하다. ex) Customer, Account 메서드 이름은 동사나 동사구가 적합하다. ex) postPayment, deletePage 추상적인 개념 하나에 단어 하나를 선택해 이를 고수한다. fetch, retrieve, get을 혼용 🤔 소감평소에도 개발을 하면서 이름짓기에 많은 고민을 하며 신중을 기하고 있기에 이번 2장은 매우 재밌게 읽을수 있었다. 이번에 소개된 많은 기법들을 어렴풋이 필요성을 느껴 개발을 할때 적용을 해왔지만, 이렇게 글로 읽고 다시 체계적으로 정리 하니 머릿속에 meme같이 제대로 정리 되지 않았던 생각들이 나름 체계를 잡는 소중한 시간이였다. 그럼에도 몇몇 부분은 읽으면서 고민을 하게되는 방식이 있었는데, 대표적으로 인터페이스에 ‘I’ 접두사를 붙이지 않는 것이 좋다고 책에서 소개 하고있다. .Net을 주로 사용했고 Microsoft Naming Conventions을 따랐기 때문에 인터페이스에 대한 네이밍에 고민을 많이하였다. 저자가 ‘I’ 접두사를 붙이지 않는 이유는 과도한 정보를 제공하며, 굳이 인터페이스라는 정보를 남에게 알릴 필요가 없다고 하였다. 현재로서는 납득이 앞의 이유가 납득이 되기 때문에, 저자가 소개한 네이밍 규칙에 따라 보려고 한다. 하지만, .Net 같이 특수한 경우애는 ‘I’ 를 고수할 필요가 있다고 생각한다. 📖 3줄 요약 그릇된 정보를 피하라 의미 있게 구분하라 한 개념에 한 단어를 사용하라","link":"/2022/01/24/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-2%EC%9E%A5-%EC%9D%98%EB%AF%B8%EC%9E%88%EB%8A%94-%EC%9D%B4%EB%A6%84/"},{"title":"[Solidity]솔리디티 보안 악성코드 숨기기","text":"원문으로 가기 Credit: Zuhaib Mohammed 이 포스트는 Zuhaib Mohammed가 작성한 Hiding Malicious Code | Hack Solidity #9를 번역한 내용이며, 임의로 첨삭한 부분이 있습니다. 모든 번역 포스트는 원작자의 동의를 받아 번역을 진행하였습니다. web3 공간은 상당히 새롭고 진화하고 있지만, 대부분의 사용자는 매우 테만합니다. 그들은 프로젝트를 조사하지 않고 단지 10배에서 100배의 수익을 기대하며 그들의 자본을 투자한다. 이번 예제에서는 컨트랙트과 상호 작용하기 전에 코드를 감사하는 것의 중요성을 이해하려고 노력할 것입니다. etherscan.io 포털을 통해 컨트랙트 코드를 확인할 수 있다는 것은 모두 알고 있습니다. 영리한 공격자dApp 개발자는 모든 사람이 보고 감사할 수 있도록 etherscan.io에 코드와 컨트랙트 주소를 게시합니다. 이것은 프로젝트에 대한 일종의 신뢰를 생성하지만, 개발자가 악성 코드를 숨길 수 있는 방법이 있습니다. 아래 주어진 예에는 Foo와 Bar라는 두 개의 컨트랙트가 있습니다. 코드를 보면 누구나 Foo가 Bar의 배포된 컨트랙트 주소를 입력받아 callBar 함수를 통해 log 함수를 호출한다는 것을 쉽게 알 수 있습니다. 그러나 악의적인 공격자는 Mal 컨트랙트에 별도의 log 함수를 작성하고 실제 배포 시 Bar 대신 Mal 컨트랙트의 배포된 컨트랙트 주소를 전달합니다. 따라서 dApp이 실행되면 Foo 컨트랙트과 상호 작용하는 모든 사용자는 Mal 컨트랙트의 log 기능을 호출하게 되고 악성 코드가 실행되어 일반적으로 사용자 자금을 훔칩니다. 일련의 사건Alice는 코드를 검토하는 사용자이고 Eve는 공격자입니다. Eve가 Mal을 배포 Eve는 Mal의 주소로 Foo를 배포 Alice는 코드를 읽은 후 Foo.callBar() 함수를 호출 Alice는 Bar.log()가 실행될 것으로 예상했지만 Mal.log()가 실행 해결책이러한 종류의 공격은 많은 감사자를 속일 수 있습니다. 따라서 한 가지 좋은 솔루션은 생성자를 통해 호출된 확인되지 않은 외부 주소에 대한 코드를 검토하는 것입니다. 솔리디티 해킹에 대한 멋진 시리즈에 대해 SmartContractProgrammer에게 감사 인사를 전합니다. 즐겁게 읽으셨기를 바랍니다. 챠오!!!","link":"/2022/01/25/%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-%EB%B3%B4%EC%95%88-%EC%95%85%EC%84%B1%EC%BD%94%EB%93%9C-%EC%88%A8%EA%B8%B0%EA%B8%B0/"},{"title":"[Clean Code]클린코드 3장 함수","text":"3장 함수🔖 읽은 범위 : 2장, 의미있는 이름 ~ 3장, 함수 💭 기억에 남는것SOLID 원칙객체지향 설계의 5가지 원칙 SRP 단일 책임의 원칙 한 클래스는 하나의 책임만 가져야 한다. OCP 개방-폐쇄 원칙 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다. LSP 리스코프 치환 원칙 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다. ISP 인터페이스 분리 원칙 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. DIP 의존성 역전 원칙 상위 모델은 하위 모델에 의존하면 안된다. 둘 다 추상화에 의존해야 한다. 추상화는 세부 사항에 의존해서는 안된다. 세부 사항은 추상화에 따라 달라진다. 함수 리팩터링 기능을 구현하는 서투른 함수를 작성한다. (길고, 복잡하고, 중복도 있다.) 테스트 코드를 작성한다. 함수 내부의 분기와 엣지값마다 빠짐없이 테스트하는 코드를 짠다. 리팩터링 한다. 코드를 다듬고, 함수를 쪼개고, 이름을 바꾸고, 중복을 제거한다. 함수는 한 가지를 해야 한다. 그 한 가자지를 잘 해야 한다. 그 한가지만을 해야한다. 🤔 소감이번 장에서도 머리속으로 어렴풋이 정리가 안되던 나만의 규칙들이, 질서정연한 규칙이 되는데 도움을 주는 고마운 내용이였다. 앞서 살펴봤던 변수 이름 짓기는 평소에도 실천을 잘하지만, 이번 함수 규칙은 상대적으로 지키지 못하는 부분이 많아 생각할거리를 많이 남겨주었다. 다만, 책이 Java를 중심으로 그리고 OOP를 사용하고 있기에 Functional programming에 이와 같은 규칙을 적용하기 위해서는 약간의 변형이 필요할 것이라 생각한다. 요즘 Go와 JS를 많이 쓰는 입장이라 책 에서 알려준 내용들을 숙달하기 위해 여러번 스스로 적용해보고 고쳐 나가는 방법을 사용해볼것이다. 📖 3줄 요약 각 함수가 너무도 명백했다. 각 함수가 이야기 하나를 표현했다. 각 함수가 너무도 멋지게 다음 무대를 준비했다.","link":"/2022/01/26/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-3%EC%9E%A5-%ED%95%A8%EC%88%98/"},{"title":"[Solidity]솔리디티 보안 허니팟","text":"원문으로 가기 Credit: Zuhaib Mohammed 이 포스트는 Zuhaib Mohammed가 작성한 Honeypot | Hack Solidity #10를 번역한 내용이며, 임의로 첨삭한 부분이 있습니다. 모든 번역 포스트는 원작자의 동의를 받아 번역을 진행하였습니다. 이번에 논의하게 될 시나리오를 더 잘 이해하기 위해 재진입(reentrancy) 공격에 대한 글을 참고하시면 좋습니다.시작하겠습니다. 허니팟은 기본적으로 공격자를 잡기 위해 배치된 트랩입니다. 이 경우 공격자의 컨트랙트 주소를 찾은 다음 CeX에서 컨트랙트 주소를 블랙리스트에 올리거나 다른 사용자 지정 작업을 수행할 수 있습니다. 허니팟 예제Bank 컨트랙트는 자금을 입출금하는 함수가 있어 재진입 공격에 취약하다. 8행에서 Logger 컨트랙트가 초기화된 것을 분명히 볼 수 있지만 Honeypot 연락처의 주소를 전달하고 공격자를 속일 수 있습니다. 스마트 컨트랙트에서 악성 코드를 숨길 수 있는 방법을 이해하려면 이 포스트를 참고하세요. 따라서 공격자가 악의적인 컨트랙트에 대한 fallback 함수를 트리거할 때. Honeypot 컨트랙트의 logger.log 함수는 종료 시 트리거됩니다. 아래와 같이 공격자의 주소를 로깅하고 있습니다. 되돌린 호출이 모든 자금을 Bank 컨트랙트로 다시 입금할지 여부는 확실하지 않지만 log 함수의 일부로 일부 코드를 추가하여 블랙리스트에 추가하거나 다른 작업을 수행할 수 있습니다. 어떤 면에서는 공격자가 미래에 그러한 공격을 하지 못하도록 막습니다. 즐겁게 읽으셨기를 바랍니다. 챠오!!!","link":"/2022/01/27/%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-%EB%B3%B4%EC%95%88-%ED%97%88%EB%8B%88%ED%8C%9F/"},{"title":"[Clean Code]클린코드 4장 주석","text":"4장 주석🔖 읽은 범위 : 3장, 함수 ~ 4장, 주석 💭 기억에 남는것주석을 최대한 쓰지 말자주석은 나쁜 코드를 보완하지 못한다.코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문 이다. 자신 이 저지른 난장판을 주석으로 설명하지 말고 개선하는 데 시간을 보내야 한다. 코드로도 의도를 표현할 수 있다! 주석은 방치된다.코드의 변화에 따라가지 못하고, 주석은 방치된다. 코드는 컴파일 되어 호출되지만, 주석은 그저 주석 이기 때문에 그 자리에 방치되고 결국 의미 없는 텍스트가 되어 버린다. 12345// 직원 에게 복지 혜택 을 받을 자격 이 있는지 검사 한다 .if ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; employee.age &gt; 65)// 의미 있는 이름 을 지으면 해결 된다 .if (employee.isEligibleForFulLBenefits()) 좋은주석구현에 대한 정보를 제공한다. 123// kk:mm:ss EEE, MMM, dd, yyyy 형식Pattern timeformat = Pattern.compiled(\\\\d*:\\\\d:\\\\d* \\\\w*, \\\\w* \\\\d* \\\\d*&quot;); 의도와 중요성을 설명한다. 123456// 스레드 를 많이 생성 하여 시스템 에 영향 을 끼쳐 테스트 를 만들 도록for (int i = 0; i &lt; 25000; i++) { SomeThread someThread = ThreadBuilder.builder().build();// 유저 로부터 입력 받을 값 을 저장할 때 trim 으로 공백 제거 필요String userName = userNameInput.trim(); 🤔 소감주석에 대해서는 깊게 생각 해본적이 없어, 이번 장에서는 새로운 정보를 얻는다 생각하며 자연스럽게 읽어 나갔다. 과제 제출용 코드에는 거의 모든 라인마다 주석을 달았고, 개인 프로젝트에서는 주석을 거의 달지 않았다. 두 경우다 내가 코드를 깨끗하게 작성하였고, 나쁘게 작성하였고의 차이가 아닌 그냥 과제에서는 주석을 요구했고 개인 프로젝트에서는 주석을 달기 귀찮아서 였다. 전자는 너무 방대한 정보로 코드를 읽는 사람의 주의를 산만하게 했을것이고, 후자는 나쁜 코드에 주석도 없으니 읽는 사람이 그 코드를 이해 하는데 많은 시간을 써야 할것이다. 이번 장에서 주석이 정말 필요할 때를 알려주었고, 대부분의 경우에는 주석을 달기 보다는 코드를 깨끗하게 만드는 것이 더 났다는 가르침을 받았다. 📖 3줄 요약 애초에 주석이 필요 없는 방향으로 코드를 작성한다. 부정확한 주석은 아예 없는 주석보다 훨씬 더 나쁘다. 진실은 한곳에만 존재한다. 바로 코드다.","link":"/2022/01/28/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-4%EC%9E%A5-%EC%A3%BC%EC%84%9D/"},{"title":"[Solidity]솔리디티 프론트 러닝(Front Running)","text":"원문으로 가기 Credit: Zuhaib Mohammed 이 포스트는 Zuhaib Mohammed가 작성한 Front Running | Hack Solidity #11를 번역한 내용이며, 임의로 첨삭한 부분이 있습니다. 모든 번역 포스트는 원작자의 동의를 받아 번역을 진행하였습니다. 블록에 트랜잭션을 추가하기 전에 모든 트랜잭션이 상주하는 트랜잭션 풀(mempool)이라는 것이 있으며, 각 트랜잭션의 가스 수수료에 따라 마이너가 해당 트랜잭션이 실행되는 순서를 결정합니다. 공격자는 프론트 러닝 공격(Front-Running Attack)이라는 것을 실행할 수 있으며, 기본적으로 더 높은 가스 요금을 설정하여 다른 사용자보다 트랜잭션을 우선시합니다. 예제를 통해 이것이 어떻게 나쁜지 알아봅시다. 공격아래는 FindThisHash 컨트랙트로, 정확한 해시를 추측하여 사용자에게 10 이더를 보상합니다. 사용자 Bob이 솔루션을 찾을 수 있다고 가정하고 솔루션을 입력하고 solve 함수를 호출합니다. 이제 악의적인 사용자 Eve는 Bob의 트랜잭션에을 위해 트랜잭션 풀을 추적합니다. 솔루션(정답)을 찾고 solve 함수에 대해 더 높은 가스 요금으로 새 트랜잭션을 시작합니다. 블록에 추가할 트랜잭션을 찾는 마이너는 가스 요금이 더 높기 때문에 Eve의 트랜잭션을 선택합니다. 결과적으로 Eve의 트랜잭션이 먼저 실행되고 10 이더가 Eve의 계정에 입금됩니다. 예방법명심해야 할 한 가지는 스마트 컨트랙트에 버그가 없더라도 트랜잭션을 재정렬할 인센티브가 있으면 프론트 러닝이 가능하다는 것입니다. commit-reveal scheme를 사용하는 submarine send을 사용하면 실제 답변을 숨기고 나중에 공개할 수 있습니다. 즐겁게 읽으셨기를 바랍니다. 챠오!!!","link":"/2022/01/29/%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-%EB%B3%B4%EC%95%88-%ED%94%84%EB%A1%A0%ED%8A%B8-%EB%9F%AC%EB%8B%9D/"},{"title":"[Clean Code]클린코드 5장 형식 맞추기","text":"5장 형식 맞추기🔖 읽은 범위 : 4장, 주석 ~ 5장, 형식 맞추기 💭 기억에 남는것가독성에 필수적이다 코드를 수월하게 읽어나갈 수 있다. 독자들에게 신뢰감을 준다. 포멧팅으로 인해 잘못해석해 버그를 발생할 위험을 줄인다! 200라인 ~200 line &lt; 500 line 코드 길이를 200줄 정도로 제한하는 것은 반드시 지킬 엄격한 규칙은 아니지만, 일반적으로 큰 파일 보다는 작은 파일 이 이해 하기 쉽다. 현업에서 의 대부분의 코드들 도 200라인 정도를 유지 한다. 코드 길이 가 200라인 을 넘어간다면, 클래스가 여러 개의 일을 하고 있을 수 있다. SRP 위배! 밀접한 개념은 서로 가까이 둔다행 묶음은 완결된 생각 하나를 표현 하므로 개념은 빈 행으로 분리한다. 변수는 사용 되는 위치에서 최대한 가까이 선언한다. 🤔 소감형식에 대한 중요성은 모두들 동의하며 최대한 그 언어의 관심과 팀 코딩 컨벤션에 따르고 있을것이다. 나 같은 경우에도, 각 언어가 지향하는 코딩 스타일을 따르려고 노력하고있다. 다른 언어들은 한줄에 대한 길의의 제한이 없지만, COBOL 같은 경우는 한줄의 길이가 80자로 제한이 되어 있다. 이것은 COBOL의 기계적 한계때문에 벌어진 현상이며, 다른 언어에서는 단순히 권장사항이지만 COBOL에서는 반드시 지켜야 하는 규칙임이 재밌는 점이다. 다른언어들도 각자 따르는 코딩 스타일이 있으니 가독성과 생산성을 위해 COBOL처럼 강제사항은 아니더라도 그것에 따르는 것이 더 나은 결과를 만들것이라 생각한다. 📖 3줄 요약 빈 행은 새로운 개념을 시작한다는 시각적 단서다. 세로 밀집도는 연광성을 의미한다. 프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야 한다.","link":"/2022/01/30/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-5%EC%9E%A5-%ED%98%95%EC%8B%9D-%EB%A7%9E%EC%B6%94%EA%B8%B0/"},{"title":"[Clean Code]클린코드 6장 객체와 자료 구조","text":"6장 객체와 자료 구조🔖 읽은 범위 : 5장, 형식 맞추기 ~ 6장, 객체와 자료 구조 1. 자료 구조 vs 객체 자료 구조(Data Structure) 객체(Object) 데이터 그 자체 비지니스 로직과 관련 자료를 공개한다. 자료를 숨기고, 추상화한다. 자료를 다루는 함수만 공개한다. 변수 사이에 조회 함수와 설정 함수로 변수를 다룬다고 객체 가 되지 않는다. (getter, setter) 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작 할 수 있다. 비지니스 로직이없고 단순히 자료만 제공 사용자 관점, 비지니스 로직에 맞춰 유용한 정보를 제공. ex) 휴대폰 배터리처럼 실제 수치는 중요하지 않고, 퍼센트를 제공 2. 절차 지향, 객체 지향절차 지향 자료 구조를 사용하는 절차적인 코드는 기본 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다. 객체 지향 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다. 3. 디미터의 법칙클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다. 클래스 C 자신이 생성한 객체 자신의 인수로 넘어온 객체 C 인스턴스 변수에 저장된 객체 휴리스틱 : 경험에 기반하여 문제를 해결하기 위해 발견한 방법. 의사 결정을 단순화하기 위한 법칙들 객체로서 옳지 않는 방법 123456789// 객체 - 기차 충돌. 디미터의 법칙을 위배한다.final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();// 자료구조 - OKfinal String outputDir = ctxt.options.scratchDir.absolutePath;// 객체에 대한 해결책이 아니다. getter를 통했을 뿐, 값을 가져오는 것은 자료구조이다.ctxt.getAbsolutePathDirectoryOption();ctxt.getScratchDirectoryOption().getAbsolutePath(); 객체로서 옳은 방법 1BufferdOutputStream bos = ctxt.createScratchFileStream(classFileName); 이전 예제는 단순히 값을 가져오고 있기 때문에 자료구조이다. 객체로 사용하려면 그 값을 가지고 기능을 제공하는데에 초점을 맞춘다. 절대경로를 ctxc를 통해 주기보다는, ctxc에서 절대경로 값을 사용하여 생성한 객체를 반환하는 기능을 부여했다. 4. DTODTO Data Transfer Object = 자료구조 다른 계층간 데이터를 교환할 때 사용한다. 로직 없이 필드만 갖는다. 일반적으로 클래스 명이 Dto(or DTO)로 끝난다. Beans Java Beans: 데이터 표현이 목적인 자바 객체 멤버 변수는 private 속성이다. getter와 setter를 가진다. 5. Active Record Database row를 객체에 맵핑하는 패턴 비즈니스 로직 메서드를 추가해 객체로 취급하는 건 바람직하지 않다. 비즈니스 로직을 담으면서 내부 자료를 숨기는 객체를 따로 생성한다. 하지만, 객체가 많아지면 복잡하고 가까운 곳에 관련 로직이 있는 것이 좋으므로 현업에서는 Entity에 간단한 메서드를 추가해 사용한다. Active Record 객체가 row를 담을 뿐 아니라 database에 대한 접근을 포함한다. Person의 속성을 담을 뿐 아니라, 생성 수정도 객체 안에서 수행할 수 있다. 사례 - Ruby on rails Data Mapper row를 담는 객체와 databse에 접근할 수 있는 객체가 분리되어 있다. Person은 값만 담고 있고, 생성, 수정 등 액션은 Person Mapper에서 담당한다. 사례 - Hibernate","link":"/2022/02/04/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-6%EC%9E%A5-%EA%B0%9D%EC%B2%B4%EC%99%80-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0/"},{"title":"[Clean Code]클린코드 7장 예외 처리","text":"7장 예외 처리🔖 읽은 범위 : 6장, 객체와 자료 구조 ~ 7장, 예외 처리 1. 예외 처리 방식오류 코드를 리턴하지 말고 예외를 던져라 try - catch로 예외처리12345678910111213141516171819202122232425262728public class DeviceController { // ... public void sendShutDown() { try { tryToShutDown(); } catch (DeviceShutDownError e) { logger.log(e); } } private void tryToShutDown() throws DeviceShutDownError { DeviceHandle handle = getHandle(DEV1); DeviceRecord record = retrieveDeviceRecord(handle); pauseDevice(handle); clearDeviceWorkQueue(handle); closeDevice(handle); } private DeviceHandle getHandle(DeviceId id) { // ... throw new DeviceShutDownError(&quot;Invalid handle for: &quot; + id.toString()); // ... } // ...} 2. Unchecked Exception을 사용하라checked Exception이 나쁜 이유 특정 메소드에서 checked exception을 throw하고 상위 메소드에서 그 exception을 catch 한다면, 모든 중간단계 메소드에 exception을 throws해야한다. 이는 OCP(개방 폐쇄 원칙)위배이다. 상위 메소드에서 하위 레벨 메소드의 디테일에 대해 알아야하기 때문이다. 필요한 경우 checked exception을 사용해야 되지만, 일반적인 경우 득보다 실이 많다. 파이썬, C#, C++, 루비는 checked exception을 지원하지 않음에도 안정적인 소프트웨어를 구현하기에 무리가 없다. 3. Exception 잘 쓰기예외에 메시지를 담아라 오류가 발생한 원인과 위치를 찾기 쉽도록, 예외를 던질 때는 전후 상황을 충분히 덧붙인다. 실패한 연산 이름과 유형 등 정보를 담아 예외를 던진다. exception wrapper예외를 감싸는 클래스를 만든다 port.open() 시 발생하는 checked exception들을 감싸도록 port를 가지는 LocalPort 클래스를 만든다. port.open()이 던지는 checked 들을 하나의 PortDeviceFailure exception으로 감싸서 던진다. 나쁜 예 12345678910111213ACMEPort port = new ACMEPort(12);try { port.open();} catch (DeviceResponseException e) { reportPortError(e); logger.log(&quot;Device response exception&quot;, e);} catch (ATM1212UnlockedException e) { reportPortError(e); logger.log(&quot;Unlock exception&quot;, e);} catch (GMXError e) { reportPortError(e); logger.log(&quot;Device response exception&quot;, e);} 좋은 예 12345678910111213141516171819202122232425262728293031LocalPort port = new LocalPort(12);try { port.open();} catch (PortDeviceFailure e) { reportError(e); logger.log(e.getMessage(), e);} finally { ...}public class LocalPort { private ACMEPort innerPort; public LocalPort(int portNumber) { innerPort = new ACMEPort(portNumber); } public void open() { try { innerPort.open(); } catch (DeviceResponseException e) { throw new PortDeviceFailure(e); } catch (ATM1212UnlockedException e) { throw new PortDeviceFailure(e); } catch (GMXError e) { throw new PortDeviceFailure(e); } } // ..} 4. 실무 예외 처리 패턴getOrElse예외 대신 기본 값을 리턴한다. null이 아닌 기본 값 도메인에 맞는 기본 값 null이 아닌 기본 값 예제나쁜 예 123456List&lt;Employee&gt; employees = getEmployees();if (employee != null) { for(Employee e : employees) { totalPay += e.getPay(); }} null을 리턴한다면, 이후 코드에서도 모두 null 체크가 있어야 한다. 좋은 예 12345678910List&lt;Employee&gt; employees = getEmployees();for(Employee e : employees) { totalPay += e.getPay();}public List&lt;Employee&gt; getEmployees() { if ( /*.. 직원이 없을 경우 .. */) { return Collections.emptyList(); }} 복수 형의 데이터를 가져올 떄는 데이터가 없음을 의미하는 컬렉션을 리턴하면 된다. null 보다 size가 0인 컬렉션이 훨씬 안전하다. 도메인에 맞는 기본 값 예제나쁜 예 1234567UserLevel userLevel = null;try { User user = user.Repository.findByUserId(userId); userLevel = user.getUserLevel();} catch (UserNotfoundException e) { userLevel = UserLevel.BASIC;} 호출부에서 예외 처리를 통해 userLevel 값을 처리한다. 코드를 계속 읽어나가면서 논리적인 흐름이 끊긴다. 좋은 예 1234567891011121314public class UserService { public static final UserLevel USER_BASIC_LEVEL = UsrLevel.BASIC; public UserLevel getUserLevelOrdefault(Long userId) { try { User user = userRepository.findByUserId(userId); return user.getUserLevel(); } catch(UserNotFoundException e) { return USER_BASIC_LEVEL; } }}UserLevel userLevel = userService.getuserLevelOrDefault(userId); 호출부 - 단순해짐 예외 처리를 데이터를 제공하는 쪽에서 처리해 호출부 코드가 심플해진다. 코드를 읽어가며 논리적인 흐름이 끊기지 않는다. 도메인에 맞는 기본 값을 도메인 서비스에서 관리한다. getOrElseThrow(기본 값이 없다면) null 대신 예외를 던진다나쁜 예 1234User user = userRepository.findByUseId(userId);if (user != null) { // user를 이용한 처리} user를 사용하는 쪽에서 매번 체크를 해야한다. 가독성 뿐만 아니라 안정성도 떨어진다. null 체크가 빠진 부분이 발생할 수 있다. 좋은 예 12345678910111213public class UserService { public static final UserLevel USER_BASIC_LEVEL = UsrLevel.BASIC; public User getUserOrElseThrow(Long userId) { User user = userRepository.findByUserId(userId); if (user == null) { throw new IllegalArgumentException(&quot;User is not found. userId = &quot; + userId) } return user; } }User user = user.Service.getUserOrElseThrow(userId); 데이터를 제공하는 쪽에서 null 체크를 하여, 데이터가 없는 경우엔 예외를 던진다. 호출부에서 매번 null 체크를 할 필요 없이 안전하게 데이터를 사용할 수 있다. 호출부의 가독성이 올라간다. 파라미터의 null을 점검하라나쁜 예 12345678public class MetricsCalculator { public double xProjection(Point p1, Point p2) { return (p2.x - p1.x) * 1.5; }}// calculator.xProjection(null, new Point(12, 13));// NullPointerException 발생 null을 리턴하는 것도 나쁘지만 null을 메서드로 넘기는 것은 더 나쁘다. null을 메서드의 파라미터로 넣어야 하는 API를 사용하는 경우가 아니면 null을 메서드로 넘기지 마라. 좋은 예 - throw new ~ 사용 12345678public class MetricsCalculator { public double xProjection(Point p1, Point p2) { if (p1 == null || p2 == null) { throw InvalidArgumentException(&quot;Invalid argument for MetricsCalculator.xProjection&quot;); } return (p2.x - p1.x) * 1.5; }} null이 들어오면 unchecked exception을 발생시킨다. 실무에서는 assert보다 예외를 던지는 방법을 훨씬 많이 사용한다. 좋은 예 - assert 사용 1234567public class MetricsCalculator { public double xProjection(Point p1, Point p2) { assert p1 != null : &quot;p1 should not be null&quot;; assert p2 != null : &quot;p2 should not be null&quot;; return (p2.x - p1.x) * 1.5; }} 실무에서는 보통 자신의 예외를 정의한다1234567891011121314151617181920212223242526public class MyProjectException extends RuntimeException { private MyErrorCode errorCode; private String errorMessage; public MyProjectException(MyErrorCode errorCode) { // } public MyProjectException(MyErrorCode errorCode, String errorMessage) { // }}public enum MyErrorCode { private String defaultErrorMessage; INVALID_REQUEST(&quot;잘못된 요청입니다.&quot;), DUPLICATED_REQUEST(&quot;기존 요청과 중복되어 처리할 수 없습니다.&quot;), // ... INTERNAL_SERVER_ERROR(&quot;처리 중 에러가 발생했습니다.&quot;);}//호출부if (request.getUserName() == null) { throw new MyProjectException(ErrorCode.INVALID_REQUEST, &quot;userName is null&quot;);} 에러 로그에서 stacktrace 해봤을 때 우리가 발생시킨 예외라는 것을 바로 인지할 수 있다. 다른 라이브러리에서 발생한 에러와 섞이지 않는다. 우리도 IllegalArgumentException을 던지는 것보다 우리 예외로 던지는게 어느 부분에서 에러가 났는지 파악하기에 용이하다. 우리 시스템에서 발생한 에러의 종류를 나열할 수 있다.","link":"/2022/02/05/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-7%EC%9E%A5-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC/"},{"title":"[Clean Code]클린코드 8장 경계","text":"8장 경계🔖 읽은 범위 : 7장, 예외 처리 ~ 8장, 경계 1. 경계란 오픈 소스, 라이브러리를 안쓰는 프로젝트는 없다. 우리가 만든 코드에 외부에서 들어온 코드를 병합해야 한다. 외부 코드는 외부에서 만든 코드인데, 외부 시스템을 호출하거나 단순히 외부에서 만들어진 코드일 수 있다. 우리 코드와 외부 코드를 깔끔하게 통합시키기 위해 경계를 잘 지어야 한다. 2. 경계 짓기 (1) 우리 코드를 보호하기캡슐화(Encapsulation) 객체의 실체 구현을 외부로부터 감추는 방식 예제 1. 나쁜 예 12map&lt;Sensor&gt; sensors = new hashMap&lt;sensor&gt;();Sensor s = sensors.get(sensorId); Map 인터페이스가 제공하는 clear 등 불필요한 기능이 노출된다. 외부 코드를 함부로 호출하면 sensor 데이터가 손상될 수 있고, 이는 의도와 벗어난다. 예제 2. 좋은 예 12345678public class Sensors { private Map sensors = new HashMap(); public Sensor getById(String id) { return (Sensor) sensors.get(id); } // ..} 캡슐화를 통해 Map을 감춘다. 원하는 기능만 공개할 수 있다. 적절한 경계로 우리 코드를 보호할 수 있다. 3. 경계 짓기 (2) 외부 코드와 호환하기Adapter 패턴 외부 코드를 호출할 때, 우리가 정의한 인터페이스대로 호출하기 위해 사용하는 패턴 4. 외부 라이브러리 테스트하기 - Learning TestLearning Test를 작성해 라이브러리를 테스트한다. 외부 코드를 배우고, 안정성도 미리 검증할 수 있다 학습 테스트는 이해도를 높인다 외부 코드의 버전이 변경됐을 때, 우리 코드와 호한되는지 확인할 수 있다. 실무에서 반드시 작성해야 하는 것은 아니지만, 여유가 된다면 작성해 두는 것이 좋다","link":"/2022/02/06/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-8%EC%9E%A5-%EA%B2%BD%EA%B3%84/"},{"title":"[Clean Code]클린코드 9장 단위 테스트","text":"9장 단위 테스트🔖 읽은 범위 : 8장, 경계 ~ 9장, 단위 테스트 1. 테스트 코드의 중요성 테스트 코드는 실수를 바로잡아준다. 테스트 코드는 반드시 존재해야 하며, 실제 코드 못지 않게 중요하다. 테스트 케이스는 변경이 쉽도록 한다. 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위테스트다. 테스트 케이스가 있으면 변경이 두렵지 않다. 테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. 테스트 커버리지가 높을수록 버그에 대한 공포가 줄어든다. 지저분한 테스트 코드는 테스트를 안하니만 못하다. 2. 테스트의 종류구글의 제안 : 70% unit tests, 20% integratoin tests, 10% end-to-end tests 1) Unit Test 프로그램 내부의 개별 컴포넌트의 동작을 테스트한다. 배포하기 전에 자동으로 실행되도록 많이 사용한다. 2) Integration Test 프로그램 내부의 개별 컴포넌트들을 합쳐서 동작을 테스트한다. Unit Test는 각 컴포넌트를 고립시켜 테스트하기 때문에 컴포넌트의 interaction을 확인하는 integration Test가 필요하다. 3) E2E Test End to End test 실제 유저의 시나리오대로 네트워크를 통해 서버의 Endpoint를 호출해 테스트한다. 3. Unit Test 작성1) 테스트 라이브러리를 사용하자 Unit : for unit test, 많이 사용 ockito : for mocking dependencies, 많이 사용 iremock : for stubbing out external services ack : for writing CDC tests elenium : for writing UI-driven end-to-end tests EST-assured : for writing REST API-driven end-to-end tests 2) Test Double Stub 원래의 구현을 단순한 것으로 대체한다. 테스트를 위해 프로그래밍된 항목에만 응답한다. Spy Stub의 역할을 하면서 호출에 대한 정보를 기록한다. 이메일 서비스에서 메시지가 몇 번 전송되었는지 확인할 때 Mock 행위를 검증하기 위해 가짜 객체를 만들어 테스트하는 방법 호출에 대한 동작을 프로그래밍 할 수 있다. Stub은 상태를 검증하고 Mock을 행위를 검증한다. 3) given-when-then 패턴을 사용하자123456789101112131415public testGetPageHierarchyAsxml() throws Exception { givenPages(&quot;PageOne&quot;, &quot;PageOne.ChildOne&quot;, &quot;PageTwo&quot;); whenRequestIsIssued(&quot;root&quot;, &quot;type:pages&quot;); thenResponseShouldBeXML();}public void testGetPageHierarchyHasRightTags() throws Exception { givenPages(&quot;PageOne&quot;, &quot;PageOne.ChildOne&quot;, &quot;PageTwo&quot;); whenRequestIsIssued(&quot;root&quot;, &quot;type:pages&quot;); thenResponseShouldContain(&quot;&lt;name&gt;PageOne&lt;/name&gt;&quot;, &quot;&lt;name&gt;ChildOne&lt;/name&gt;&quot;, &quot;&lt;name&gt;PageTwo&lt;/name&gt;&quot;);} given : 테스트에 대한 pre-condition when : 테스트하고 싶은 동작 호출 then : 테스트 결과 확인","link":"/2022/02/07/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-9%EC%9E%A5-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"title":"[Clean Code]클린코드 10장 클래스","text":"10장 클래스🔖 읽은 범위 : 9장, 단위 테스트 ~ 10장, 클래스 1. 캡슐화 되어야 한다 클래스를 개발할 때 기본적으로 구현을 감추고, 외부 객체와 상호작용 하는 부분만 노출한다. 외부의 잘못된 사용을 방지한다. 경계에서 배웠던 부분(Map) 2. 단일 책임 원칙(SRP)클래스는 작아야 한다. 함수와 마찬가지로 클래스도 작아야 한다. 함수는 라인 수로 크기를 측정했는데, 클래스는 맡은 책임의 수로 크기를 측정한다. 클래스 설명은 만일(if), 그리고(and), 하며(or), 하지만(but)을 사용하지 않고 25단어 내외로 가능해야 한다. -&gt; 책임이 한가지 이어야 한다. 작은 클래스가 많은 시스템이든 큰 클래스가 몇 개 뿐이 시스템이든 돌아가는 푸품은 그 수가 비슷하다. 큼직한 다목적 클래스 몇 개로 이뤄진 시스템은 (변경을 가할 때) 당장 알 필요가 없는 사실까지 들이밀어 독자를 방해한다. 작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며, 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다. 나쁜 예 1234567public class SuperDashboard extends JFrame implements MetaDataUser { public Component getLastFocusedComponent() public void setLastFocused(Component lastFocused) public int getMajorVersionNumber() public int getMinorVersionNumber() public int getBuildNumber()} focuse, version 두가지 책임이 보인다. 좋은 예 12345public Version { public int getMajorVersionNumber() public int getMinorVersionNumber() public int getBuildNumber()} 다른 곳에서도 재활용 할 수 있다. 3. 낮은 결합도, 높은 응집도 결합도란 다른 모듈간의 의존도를 말한다. 응집도란 모듈 내부의 기능 집중도를 말한다. 결합도는 낮을 수록, 응집도는 높을 수록 유지보수성이 좋다. 1) 문제점 결합도가 높은 클래스의 문제점 연관된 클래스가 변경되면 수정이 필요하다. 결합도가 높으면 연관된 클래스들을 모두 이해해야 한다. 응집도가 낮은 클래스의 문제점 여러 기능이 있으므로 이해하기 어렵다 재사용하기 어렵다. 2) 낮은 결합도 시스템의 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다. DIP : 클래스가 상세한 구현이 아니라 추상화에 의존해야한다. 추상화를 이용하면 테스트코드 짜기에 용이하다. 나쁜 예 12345678910public class TokyoStockExchange { public Money currentPrice(String symbol);}public Portfolio { private TokyoStockExchange tokyoStockExchange; public Portfolio(TokyoStockExchange exchange) { this.tokyoStockExchange = tokyoStockExchange; }} TokyoStockExchange 함수의 API가 5분마다 값이 달라지는 상황이다. Portfolio 클래스 테스트 코드를 짜기 어렵다. 좋은 예 12345678910111213141516public interface StockExchange { Money currentPrice(String symbol);}public class TokyoStockExchange implements StockExchange { public Money currentPrice(String symbol) { // call API ... }}public Portfolio { private stockExchange exchange; public Portfolio(StockExchange exchange) { this.exchange = exchange; }} StockExchange 인터페이스를 통해 Portfolio와 tokyoStockExchange의 결합도를 끊어준다. 테스트 코드 1234567891011121314151617public class PortfolioTest { private FixedStockExchangeStub exchange; private Portfolio portfolio; @Before protected void setUp() throws Exception { exchange = new FixedStockExchangeStub(); exchange.fix(&quot;MSFT&quot;, 100); portfolio = new Portfolio(exchange); } @Test public void GivenFiveMSFTTotalShouldBe500() throws Exception { portfolio.add(5, &quot;MSFT&quot;); AssertEquals(500, portfolio.value()); }} 객체를 Mockking하면 변경되는 클래스도 테스트할 수 있다. 확장될 가능성이 적다면 일단 결합하고, 나중에 추상화해도 좋다. 3) 높은 응집도 클래스는 인스턴스 변수 수가 적어야 한다. 메서드는 인스턴스 변수를 하나 이상 사용해야 한다. 메서드가 인스턴스 변수를 많이 사용할수록 응집도가 높다 응집도가 높다 = 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다 = 서로 관계있는 애들만 모여있다. 클래스가 응집도를 잃어간다면 함수를 쪼개야한다. 좋은 예 123456789101112131415161718192021public class Stack { private int topOfStack = 0; List&lt;Integer&gt; elements = new LinkedList&lt;Integer&gt;(); public int size() { return topOfStack; } public void push(int element) { topOfStack++; elements.add(element); } public int pop() throws PoppedWhenEmpty { if (topOfStack == 0) throw new PoppedWhenEmpty(); int element = elements.get(--topOfStack); elements.remove(topOfStack); return element; }} 4. 변경하기 쉬워야 한다나쁜 예 1234567891011121314public class Sql { public Sql(String table, Column[] columns) public String create() public String insert(Object[] fields) public String selectAll() public String findByKey(String keyColumn, String keyValue) public String select(Column column, String pattern) public String select(Criteria criteria) public String preparedInsert() private String columnList(Column[] columns) private String valuesList(Object[] fields, final Column[] columns) private String selectWithCriteria(String criteria) private String placeholderList(Column[] columns)} 새로운 SQL을 추가할 때도 수정이 발생하고, 기존 SQl문을 수정할 때도 수정이 발생하므로 OCP가 위반된다. 좋은 예 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051abstract public class Sql { public Sql(String table, Column[] columns) abstract public String generate();}public class CreateSql extends Sql { public CreateSql(String table, Column[] columns) @Override public String generate()}public class SelectSql extends Sql { public SelectSql(String table, Column[] columns) @Override public String generate()}public class InsertSql extends Sql { public InsertSql(String table, Column[] columns, Object[] fields) @Override public String generate() private String valuesList(Object[] fields, final Column[] columns)}public class SelectWithCriteriaSql extends Sql { public SelectWithCriteriaSql( String table, Column[] columns, Criteria criteria) @Override public String generate()}public class SelectWithMatchSql extends Sql { public SelectWithMatchSql(String table, Column[] columns, Column column, String pattern) @Override public String generate()}public class FindByKeySql extends Sql public FindByKeySql( String table, Column[] columns, String keyColumn, String keyValue) @Override public String generate()}public class PreparedInsertSql extends Sql { public PreparedInsertSql(String table, Column[] columns) @Override public String generate() { private String placeholderList(Column[] columns)}public class Where { public Where(String criteria) public String generate()}public class ColumnList { public ColumnList(Column[] columns) public String generate()} 공개 인터페이스를 전부 SQL 클래스에서 파생하는 클래스로 만들고, 비공개 메서드는 해당 클래스로 옮기고, 공통된 인터페이스는 따로 클래스로 뺐다. 기존의 클래스를 건드리지 않아도 된다.","link":"/2022/02/08/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-10%EC%9E%A5-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"title":"[Clean Code]클린코드 11장 시스템","text":"11장 시스템🔖 읽은 범위 : 10장, 클래스 ~ 11장, 시스템 1. 관심사 분리 construction(생성)과 use(사용)은 아주 다르다. 소프트웨어 시스템은 (어플리케이션 객체를 제작하고 의존성을 서로 ‘연결’하는) 준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 한다. 객체의 생성과 객체를 사용하는 부분을 분리한다. 1) 시작에 대한 관심사 분리 객체의 생성은 시작 단계에서, 비즈니스 로직은 객체를 사용하는데 집중한다. 시작 단계는 모든 어플리케이션이 풀어야할 관심사이다. main 함수에서 시스템에 필요한 객체를 생성한 후 어플리케이션에 넘긴다. 어플리케이션은 그저 만들어진 객체를 사용한다. 모든 객체가 잘 생성되었다고 가정하고, 객체를 이용한 개발에 집중할 수 있다. 2) 요청에 대한 관심사 분리Filter, Interceptor, AOP 서블릿 필터는 Dispatcher Servlet 이전에 실행이 되는데, 요청 내용을 변경하거나 요청을 처리하기 전에 작업을 수행할 수 있다. Filter와 Interceptor는 Servlet 단위에서 실행된다. 반면 AOP 는 메소드 앞에서 Proxy 패턴으로 실행된다. 인터셉터는 여러 개를 사용할 수 있고 로그인 처리, 권한 체크, 프로그램 실행시간 계산작업, 로그 확인 등의 업무 처리에 활용된다. AOP는 메서드 앞에서 Proxy 패턴으로 실행된다. 주로 ‘로깅’, ‘트랜잭션’, ‘에러처리’ 등 비즈니스 단의 메서드에서 조금 더 세밀하게 조정하고 싶을 때 사용한다. AOP는 주소, 파라미터, 어노테이션 등 다양한 방법으로 대상을 지정할 수 있다. 2. Dependency Injection(의존성 주입) 객체 의존성을 DI 컨테이너에 맡긴다. Setter 메소드 or 생성자 인수를 통해 의존성을 주입한다. DI 컨테이너는 요청이 들어올 때 필요한 객체의 인스턴스를 만든 후 의존성을 설정한다. 예 : Spring IOC Container Sprint IOC Container 객체 의존성을 DI 컨테이너에 맡긴다. DI 컨테이너가 객체를 알아서 wiring 해준다. 3. Cross Cutting Concerns(횡단 관심 분리) 비즈니스 로직(핵심 관심사) 외에 Logging, Transaction 관리, Security 등 신경써야 할 관심사들이 많다. 관심사들은 많은 어플리케이션 레이어에 퍼져있는데, 이 관심사들을 분리해 처리하는 것이 효율적이다. 비즈니스 로직(핵심 관심사)에 집중할 수 있게 된다. before 12345678910public Response executeBusinessLogic(Request request) { // 공통 기능 checkAuth(request); // 비즈니스 로직 Response response = businesslogic(userName, message); // 공통 기능 logging(response);} after 123456public Response executeBusinessLogic(Request request) { // 비즈니스 로직 Response response = businesslogic(userName, message);}// 공통 기능은 별도의 코드에서 관리한다. 해결 방법 자바 프록시 단순한 상황에 적합하다. 개별 객체나 클래스에서 메서드 호출을 감싸는 경우가 좋은 예다. 순수 자바 AOP 프레임워크 대부분의 프록시 코드는 판박이라 도구로 자동화할 수 있다. 순수 자바 관점을 구현하는 스프링 AOP, JBoss AOP 프레임 워크는 내부적으로 프록시를 사용한다. 설정 파일이나 API를 사용해 객체의 역할을 설정한다. 객체를 얻어올 때는 (XML 파일에 설정했던 DI 컨테이너에게 객체를 요청(getBean)한다. EJB3 - JPA같은 객체 영속성 관리 표준 API 모든 정보가 annotation 속에 있어서 코드 자체가 깔끔하고 가독성이 좋다. annotation에 있는 영속성 정보 전부 또는 일부를 XML 설정으로 옮겨도 된다.(실무에서는 annotation 사용을 선호)","link":"/2022/02/09/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-11%EC%9E%A5-%EC%8B%9C%EC%8A%A4%ED%85%9C/"},{"title":"[Clean Code]클린코드 12장 창발성","text":"12장 창발성🔖 읽은 범위 : 11장, 시스템 ~ 12장, 창발성 1. 창발적 설계란1) 창발성 하위 계층에는 없는 특성이나 행동이 상위 계층(전체 구조)에서 자발적으로 돌연히 출연하는 현상 각각의 개미는 집을 지을 능력이 없지만, 작은 개미들의 상호작용을 통해 집이라는 결과물이 나온다. 이처럼 작은 요소들의 상호작용의 반복이 전체 구조에 영향을 미친다. 2) 창발적 설계단순한 4가지를 반복하다보면 전체적으로 깨끗한 코드가 만들어진다. 모든 테스트를 실행한다. 중복을 없앤다. 프로그래머 의도를 표현한다. 클래스와 메서드 수를 최소로 줄인다. -&gt; 실용적 관점에서 타협한다. 2. 모든 테스트를 실행한다 모든 테스트 케이스를 항상 통과하는 시스템은 ‘테스트가 가능한 시스템’이다. 테스트가 불가능한 시스템은 검증도 불가능하고, 절대 출시하면 안된다. 테스트가 가능한 시스템을 만들려고 애쓰면 설계 품질이 높아진다. 크기가 작고 목적 하나만 수행하는 클래스가 나온다. 결합도가 높으면 테스트 케이스를 작성하기 어렵기 때문에 결합도를 낮추는 설계를 하게 된다. ‘모든 테스트를 실행한다.’는 규칙을 따르면 시스템은 낮은 결합도와 높은 응집도라는 목표를 저절로 달성할 수 있다. 3. 중복을 없앤다1) 기존의 코드를 최대한 재활용한다.예제 12345678int size() {}boolean isEmpty() {}// 각 메서드를 따로 구현하는 방법도 있지만, 중복을 없애기 위해 서로 호출하도록 한다.boolean isEmpty() { return this.size() == 0;} 2) 중복을 없앤다.나쁜 예 123456789101112131415161718public void scaleToOneDimension(float desiredDimension, float imageDimension) { if (Math.abs(desiredDimension - imageDimension) &lt; errorThreshold) return; float scalingFactor = desiredDimension / imageDimension; scalingFactor = (float)(Math.floor(scalingFactor * 100) * 0.01f); RenderedOpnewImage = ImageUtilities.getScaledImage(image, scalingFactor, scalingFactor); image.dispose(); System.gc(); image = newImage;}public synchronized void rotate(int degrees) { RenderedOpnewImage = ImageUtilities.getRotatedImage(image, degrees); image.dispose(); System.gc(); image = newImage;} 좋은 예 1234567891011121314151617public void scaleToOneDimension(float desiredDimension, float imageDimension) { if (Math.abs(desiredDimension - imageDimension) &lt; errorThreshold) return; float scalingFactor = desiredDimension / imageDimension; scalingFactor = (float) Math.floor(scalingFactor * 10) * 0.01f); replaceImage(ImageUtilities.getScaledImage(image, scalingFactor, scalingFactor));}public synchronized void rotate(int degrees) { replaceImage(ImageUtilities.getRotatedImage(image, degrees));}private void replaceImage(RenderedOpnewImage) { image.dispose(); System.gc(); image = newImage;} 별도의 클래스로 분리하면 추후 재활용성이 높아진다. Template Method 패턴 알고리즘의 구조를 상위 클래스의 메서드에서 정의하고, 하위 클래스에서 자신에 맞게 세부 알고리즘을 정의한다. 구현하려는 알고리즘에 일정한 단계가 있고, 세부 단계마다 조금씩 구현 내용이 다를 때 사용한다 알고리즘의 여러 단계를 각 메서드로 선언하고, 그 알고리즘을 수행항 템플릿 메서드를 만든다. 하위 클래스에서는 나눠진 메서드(단계)를 구현한다. DailyRoutine - 알고리즘 getUp 등 메서드 - 알고리즘의 각 단계 나쁜 예 12345678910111213141516171819public class VacationPolicy { public void accrueUSDDivisionVacation() { // 지금까지 근무한 시간을 바탕으로 휴가 일수를 계산하는 코드 // ... // 휴가 일수가 미국 최소 법정 일수를 만족하는지 확인하는 코드 // ... // 휴가 일수를 급여 대장에 적용하는 코드 // ... } public void accrueEUDivisionVacation() { // 지금까지 근무한 시간을 바탕으로 휴가 일수를 계산하는 코드 // ... // 휴가 일수가 유럽연합 최소 법정 일수를 만족하는지 확인하는 코드 // ... // 휴가 일수를 급여 대장에 적용하는 코드 // ... }} 좋은 예 1234567891011121314151617181920212223abstract public class VacationPolicy { public void accrueVacation() { calculateBseVacationHours(); alterForLegalMinimums(); applyToPayroll(); } private void calculateBaseVacationHours() { /* ... */ }; abstract protected void alterForLegalMinimums(); private void applyToPayroll() { /* ... */ };}public class USVacationPolicy extends VacationPolicy { @Override protected void alterForLegalMinimums() { // 미국 최소 법정 일수를 사용한다. }}public class EUVacationPolicy extends VacationPolicy { @Override protected void alterForLegalMinimums() { // 유럽연합 최소 법정 일수를 사용한다. }} 공통된 알고리즘을 accrueVacation 템플릿 메서드에 담고, 동일한 내용에 대해서는 메서드를 구현하고 다른 내용(미국/유럽연합)은 하위 클래스가 구현하도록 abstract 메서드로 만든다. 하위 클래스 UsVacationPolicy, EUVacationPolicy는 각자의 알고리즘을 구현한다. 4. 의도를 표현한다 좋은 이름을 선택한다. 함수와 클래스의 크기를 가능한 줄인다. 작은 클래스와 작은 함수는 이름 짓기도 쉽다. 표준 명칭을 사용한다. 다른 개발자가 보고 바로 이해할 수 있도록 디자인 패턴을 사용했다면, 그 이름을 클래스에 넣어준다. 단위 테스트 케이스를 꼼꼼하게 작성한다. 다른 사람들을 위해 조금이라도 더 읽기 쉽게 만드려고 노력한다. 5. 실용적 관점에서 타협한다 여러가지 규칙에 극단적으로 심취해 클래스와 메서드를 무수하게 만들지 마라 결국 좋은 코드를 만드는 이유는 생산성을 올리기 위한 것이다. 실용적인 관점에서 타협해야 한다. 확장성이 떨어지는 예제 123456789101112class PaymentController { @RequestMapping(value = &quot;/api/payment&quot;, method = RequestMethod.POST) public void pay(@RequestBody ShinhanCardDto.PaymentRequest req) { shinhanCardPaymentService.pay(req); }}class ShinhanCardPaymentService { public void payShinhanCardDto.PaymentRquest req) { shinhanCardApi.pay(req); }} chap 3. 함수에서는 확장성을 높이기 위해 인터페이스를 활용했다. 하지만 카드사가 직영 가맹점이라 다른 카드는 절대 쓸수 없는, 즉 확장에 유연할 필요가 없는 경우라면 인터페이스를 추가할 필요가 없다. 새로운 카드사와 합병해서 두가지 카드를 쓰게되는 것 경우가 발생하면, 그때 확장하면 된다. 거의 발생하지 않을 일에 미리 투자하는 비용이 더 크다.","link":"/2022/02/10/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-12%EC%9E%A5-%EC%B0%BD%EB%B0%9C%EC%84%B1/"},{"title":"[Clean Code]클린코드 13장 동시성","text":"13장 동시성🔖 읽은 범위 : 12장, 창발성 ~ 13장, 동시성 1. 동시성 프로그래밍이란1) 동시성이 구현되지 않은 경우 서버(코어)가 클라이언트의 요청이 완료되도록 그저 기다리기 때문에 다른 작업이 실행되지 못한다. 2) 병렬성을 구현한 경우(서버 증설) 서버의 수가 늘어나서 한번에 처리할 수 있는 작업의 수는 늘어났지만, 이 역시 받은 요청을 처리하는 동안 서버는 다른 작업을 하지 못한다. 3) 동시성을 구현한 경우 클라이언트의 요청이 완료되지 않더라도 중간에 다른 작업을 할 수 있다. 동시성을 구현하다고 해서 클라이언트의 입장에서 자신의 요청이 빨리 처리되는 것은 아니다. 어플리케이션 입장에서 효율적으로 코어를 사용해 처리량이 높아지는 것이다. 보통 cpu는 멀티 코어를 지원한다. 언어레벨에서 하드웨어의 멀티코어를 적절하게 사용하도록 지원하기 때문에 동시성만 신경써서 개발하면 된다. 더불어 내 어플리케이션이 동작하는 머신의 환경이 효율적을 돌아가도록 내 어플리케이션에 메모리 누수나 자원이 낭비되지 않도록 신경쓴다. 2. 동시성 프로그래밍이 필요한 이유동시성 프로그래밍의 미신과 오해(1) 동시성은 항상(X)/ 때로(O) 성능을 높여준다. 대기시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아지다. 예1 : 웹 브라우저에서 여러가지 이미지 리소스들을 불러와 다운로드 할 때 예2 : Servlet - 참고자료 : https://medium.com/@wminikuma/java-servlet-dc81ab09139c (2) 동시성을 구현해도 설계는 변하지 않는다.(X) / 설계를 바꿔야 한다.(O 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다. ‘무엇’과 ‘언제’를 분리하면 시스템의 구조가 크게 달라진다. (3) Web이나 EJB와 같은 컨테이너를 사용해도 동시성을 이해해야한다.(O) 어플리케이션을 컨테이너를 통해 멀티 쓰레드를 사용하는 것이기 때문에 컨테이너의 동작을 이해해야한다. 동시 수정, 데드락 같은 문제를 피할 수 있는지를 알아야한다. 3. 안전한 동시성 프로그래밍 규칙1) 단일 책임 원칙(SRP) 설계동시성 관련 코드는 다른 코드와 분리하라. 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다. 동시성 코드에는 독자적인 난관이 있다. 다른 코드에서 겪는 난관과 다르며 훨씬 어렵다. 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다. 주변에 있는 다른 코드가 발목을 잡지 않더라도 동시성 하나만으로도 충분히 어렵다. 2) 자료 범위를 제한하라.공유 자료를 최대한 줄여라 동시 수정 문제를 피하기 위해 객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 보호하라 보호할 임계영역을 빼먹거나, 모든 임계영역을 보호했는지 확인하느라 수고가 드므로 임계영역의 수를 최소화 해야 한다. 3) 자료 사본을 사용하라공유 자료를 줄이려면, 최대한 공유하지 않는 방법이 제일 좋다. 객체를 복사해 읽기 전용으로 사용한다. 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져온다. 사본을 사용하는 방식으로 내부 잠금을 없애 수행 시간을 절약하는 것이 사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다. 4) Thread는 가능한 독립적으로 구현한다.다른 스레드와 자료를 공유하지 않는다. 서블릿처럼 각 Thread는 클라이언트 요청 하나를 처리한다. 모든 정보는 비공유 출처(client의 request)에서 가져오며 로컬 변수에 저장한다. 각 서블릿은 마치 자신이 독자적인 시스템에서 동작하는 양 요청을 처리한다. 5) 라이브러리를 이해하라java.util.concurrent 패키지를 익혀라 Thread Safe한 컬렉션을 사용한다. ex) ConcurrnetHashMap, AtomicLong 서로 무관한 작업을 수행할 때는 executor 프레임워크를 사용한다. 가능하다면 Thread가 Blocking되지 않는 방법을 사용한다. 6) 동기화하는 메서드 사이에 존재하는 의존성을 이해하라공유 객체 하나에는 메서드 하나만 사용하라 클라이언트 잠금 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠근다. 마지막 메서드를 호출할 때까지 잠금을 유지한다. 자원을 사용하는 클라이언트마다 synchronized 처리를 해줘야 하므로 비효율적이다. 서버에서 잠금 서버에다 “서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는” 메서드를 구현한다. 클라이언트는 이 메서드를 호출하기만 하면 된다. 연결(Adapter) 서버 잠금을 수행하는 중간 단계를 생성한다. ‘서버에서 잠금’ 방식과 유사하지만, 원래 서버는 변경하지 않는다. 서버의 코드가 외부 코드라서 수정할 수 없을 때 우리 코드에서 Adapter를 만들어 사용한다. 4. 동시성 테스트 방법 테스트를 했다고 동시성 코드가 100% 올바르다고 증명하기는 불가능하다. 하지만 충분한 테스트는 위험을 낮춘다. 문제를 노출하는 테스트 케이스를 작성하라 프로그램의 설정과 시스템 설정과 부하를 바꿔가면 자주 돌려라 테스트가 실패하면 원인을 추적하라 다시 돌렸더니 통과한다는 이유로 그냥 넘어가면 절대 안된다. 1) 코드에 보조 코드를 넣어 돌려라드물게 발생하는 오류를 자주 발생시키도록 보조 코드를 추가한다. 코드에 wait(), sleap(), yield(), priority() 함수를 추가해 직접 구현한다. 보조코드를 넣어주는 도구를 사용해 테스트한다. 다양한 위치에 ThreadJigglePoint.jiggle()을 추가해 무작위로 sleep(), yield()가 호출되도록 한다. 테스트 환경에서 보조 코드를 돌려본다. 2) 동시성 코드를 실제 환경이 테스트 환경에서 돌려본다.다양한 요청과 상황에서 동시성 코드가 정상적으로 동작하는지 확인한다. 배포하기 전에 테스트 환경에서 충분히 오랜시간 검증한다. 동시성 코드를 배포한 후에 모니터링을 통해 문제가 발생하는지 지켜본다.","link":"/2022/02/11/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-13%EC%9E%A5-%EB%8F%99%EC%8B%9C%EC%84%B1/"},{"title":"[Clean Code]클린코드 14장 점진적인 개선","text":"14장 점진적인 개선🔖 읽은 범위 : 13장, 동시성 ~ 14장, 점진적인 개선 1. 책의 예제1) 코드 초안 모든 로직이 하나의 클래스에 들어가 있다. 처음부터 지저분한 코드를 짜려는 생각은 없었고, 코드를 어느정도 손봤지만, 새로운 인수 유형이 들어오면서 재앙이 시작됐다. 이제는 개선해야 할 때라는 것을 깨닫고, 변경 전후 시스템이 동일하게 돌아간다는 사실을 확인하기 위해 테스트들을 작성해뒀다. 자잘하게 점진적으로 개선해나갔다. 2) 코드 완성본 Args 클래스에서 코드 중복을 최소화하고, ArgsException 클래스를 분리했다. ArgumentMarshaler 클래스를 통해 여러 인수에 대한 추후 확장성을 만들어냈다. 코드만 분리해도 설계가 좋아진다. 관심사를 분리하면 코드를 이해하고 보수하기 훨씬 더 쉬워진다. 2. 점진적으로 개선하기 코드가 나빠지고 있음을 느꼈을 때 기능을 추가하지 않고 개선을 시작한다. 테스트 코드를 작성한다. 변경을 가한 후에도 시스템이 변경 전과 똑같이 돌아가야 한다. 테스트 코드가 없다면 작성하고, 코드를 수정하기 전 상태에서 모든 테스트가 통과해야 한다. 점진적으로 개선한다. 책임에 따라 클래스를 나누고, 코드를 옮긴다. 테스트가 깨지지 않도록 확인하며 자잘한 변경을 조금씩 진행한다. 3. IDE를 활용해 점진적으로 개선하기참고자료 : https://github.com/cheese10yun/IntelliJ/blob/master/nomal/refactoring.md","link":"/2022/02/12/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-14%EC%9E%A5-%EC%A0%90%EC%A7%84%EC%A0%81%EC%9D%B8-%EA%B0%9C%EC%84%A0/"},{"title":"[Solidity]솔리디티 보안 타임스탬프 조작 차단","text":"원문으로 가기 Credit: Zuhaib Mohammed 이 포스트는 Zuhaib Mohammed가 작성한 Block Timestamp Manipulation | Hack Solidity #12를 번역한 내용이며, 임의로 첨삭한 부분이 있습니다. 모든 번역 포스트는 원작자의 동의를 받아 번역을 진행하였습니다. 이 글은 다른 글다 짧을 겁니다. block.timestamp는 다음과 같은 제약 조건으로 채굴자가 조작할 수 있습니다. 부모 시간보다 이른 시간으로 스탬프가 찍힐 수 없습니다. 너무 먼 미래일 수 없다. 미래에 block.timestamp를 15로 나누도록 설정하여 이를 조작할 수 있는 대규모 연산 능력을 가진 사용자 Eve를 상상해 보십시오. 결과적으로 모든 이더를 그녀의 계정으로 전송합니다. 해결책block.timestamp를 엔트로피 및 임의성의 소스로 사용하지 마십시오. 스마트 컨트랙트에 임의성을 도입하는 방법에 대해서는 ChainlinkVRF를 확인하십시오. 스마트 컨트랙트의 Randomness에 대한 다른 게시물도 확인하십시오. 즐겁게 읽으셨기를 바랍니다. 챠오!!!","link":"/2022/02/14/%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-%EB%B3%B4%EC%95%88-%ED%83%80%EC%9E%84%EC%8A%A4%ED%83%AC%ED%94%84-%EC%A1%B0%EC%9E%91-%EC%B0%A8%EB%8B%A8/"},{"title":"[Solidity]솔리디티 보안 시그니처 리플레이","text":"원문으로 가기 Credit: Zuhaib Mohammed 이 포스트는 Zuhaib Mohammed가 작성한 Signature Replay | Hack Solidity #13를 번역한 내용이며, 임의로 첨삭한 부분이 있습니다. 모든 번역 포스트는 원작자의 동의를 받아 번역을 진행하였습니다. 두 명의 소유자 Alice와 Eve가 있는 MultiSig Wallet을 상상해 보십시오. Eve가 MultiSig Wallet에서 자금을 인출하려는 경우 총 3개의 트랜잭션이 발생합니다. Eve의 1 ETH 인출 요청 승인 Alice의 1 ETH 출금 요청 승인 1 ETH를 Eve에게 전송 이제 서명(signature)이 사용되는 예를 살펴보겠습니다. 이 경우 하나의 트랜잭션만 필요합니다. Alice는 Eve가 1 ETH를 인출하여 Eve 오프체인으로 보낼 수 있다는 메시지에 서명합니다. 그런 다음 Eve는 Alice의 서명과 자신의 서명으로 transfer 함수를 호출합니다. 우리 모두는 이더리움의 가스 요금이 비싸고 하나에 대해 3개의 트랜잭션을 수행하는 것이 시간과 가스 낭비라는 것을 알고 있습니다. 위의 솔루션은 효율성을 추가하지만 Eve가 동일한 서명을 여러 번 리플레이하거나 재사용하여 자금을 인출할 경우 문제가 발생합니다. 이러한 이벤트에 대한 세 가지 시나리오와 각각에 대한 가능한 솔루션에 대해 논의해 보겠습니다. 첫 번째 시나리오는 동일한 스마트 컨트랙트에서 서명을 여러 번 사용할 수 있는 경우입니다. 이 경우 서명하기 전에 nonce 값을 추가하면 문제가 해결됩니다. 두 번째 시나리오는 동일한 코드가 여러 주소에 배포되는 경우입니다. 이 경우 nonce에 서명하고 구현하기 전에 철회가 발생해야 하는 컨트랙트의 주소도 추가합니다. 세 번째 시나리오는 컨트랙트에서 create2를 사용하여 배포되고 컨트랙트에 selfdestruct 함수가 있는 경우입니다. create2는 항상 동일한 주소에 컨트랙트를 배포합니다. Eve는 컨트랙트를 생성 및 파기하는 루프를 수행할 수 있으며 모든 재생성 중에 nonce가 재설정되는 것처럼 서명을 반복적으로 사용할 수 있습니다. create2 함수의 작동에 대해 명확하지 않습니다. 앞으포 그것을 연구하고 여기에 링크 할 것입니다. 이론은 충분하니 예를 들어 보겠습니다. 예제우리는 deposit 및 transfer 함수가 있는 MultiSigWallet 컨트랙트를 가지고 있습니다. transfer 함수에는 Alice와 Eve의 서명을 받는 _sigs 인수가 있습니다. 트랜잭션 해시(txHash)가 생성되어 인출을 진행하기 전에 소유자가 서명한 경우 나중에 확인됩니다. 코드에서 txHash에 임의성을 추가하거나 이전에 서명이 사용되었는지 확인하는 메커니즘이 없음을 알 수 있습니다. 해결책리플레이 공격을 방지하기 위해 txHash 생성에 사용되는 인수로 nonce를 전달합니다. 또한, 기본적으로 이전 txHash를 추적하고 현재 txHash가 이전에 사용되었는지 확인하는 실행이라는 매핑을 선언했습니다. 시그니처 공격을 성공적으로 방지합니다. txHash를 생성할 때 자금을 인출해야 하는 컨트랙트의 주소를 추가하여 더 안전하게 보호할 수 있습니다. 즐겁게 읽으셨기를 바랍니다. 챠오!!!","link":"/2022/02/15/%EC%86%94%EB%A6%AC%EB%94%94%ED%8B%B0-%EB%B3%B4%EC%95%88-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98-%EB%A6%AC%ED%94%8C%EB%A0%88%EC%9D%B4/"},{"title":"[웹] 성능 최적화 - part 1","text":"웹 성능 최적화의 주요 포인트로딩 성능 화면에 필요한 리소스들을 서버로부터 가지고 오는 구간 렌더링 성능 리소스를 화면에 표시하는 구간 로딩 성능이미지 최적화 이미지를 상황에 맞게 사이즈 축소 (썸네일) 이미지 CDN을 사용하여 상황에 맞는 크기별로 이미지 로딩 ex) https://imgix.com/ bottleneck 코드 최적화 크롬 개발자 도구의 성능탭을 사용하여 병목이 되는 구간의 컴포넌트 코드 최적화 함수 성능 개선 bundle 파일 최적화 현재 화면에 필요한 코드들만 로딩하도록 Code Splitting 및 Lazy Loading (코드 분할) 중복되는 코드 없이 적절한 타이밍에 로드 bundle 분석은 bundle-analyzer 사용 텍스트 압축 리소스(HTML, Javascript, CSS)들을 서버에서 압축하여 리소스 다운로드 성능을 개선 서버 또는 CDN에서 제공하는 기능을 사용하여 압축 (CloudFront, NGINX) 렌더링 성능브라우저 렌더링 브라우저에서 초당 60 프레임(60FPS)이상 화면을 그리지 못하면 화면이 버벅이는 쟁크 현상이 발생한다. (자바스크립트 최적화) 브라우저 렌더링 과정 HTML, CSS를 각각 트리구조의 DOM, CSSOM의 데이터 모델로 변환 DOM, CSSOM을 화면 렌더링을 위한 Render Tree 모델로 조합 Layout - 각 요소들의 화면에 표시될 위치와 크기를 계산 (Reflow) Paint - 각 요소에 필요한 색상 정보를 표현 (Repaint) Composition - 여러개로 만들어진 Layer를 합성 자바스크립트 최적화 브라우저는 어떻게 동작하는가 브라우저 렌더링 원리 그리고 가상돔 크기나 위치를 변경하는 Layout(Reflow)이 발생하면 Paint 작업을 다시 수행한다. GPU가 관여할 수 있는 속성(transform, opacity)을 변경하면 Layout, Paint 동작이 생략된다. CSS Trigger 사이트를 참고하여 렌더링 비용을 고려하여 작업하는것이 좋다. (https://csstriggers.com/) 컴포넌트 Lazy Loading (https://benestudio.co/how-to-lazy-load-your-react-components/) React.lazy 12345// without lazyimport OtherComponent from &quot;./OtherComponent&quot;;// with lazyconst OtherComponent = React.lazy(() =&gt; import(&quot;./OtherComponent&quot;)); Suspense 12345678910111213//using suspenseimport React, { Suspense } from &quot;react&quot;;const OtherComponent = React.lazy(() =&gt; import(&quot;./OtherComponent&quot;));const MyComponent = () =&gt; { return ( &lt;div&gt; &lt;Suspense fallback={&lt;div&gt;Loading ... &lt;/div&gt;}&gt; &lt;OtherComponent /&gt; &lt;/Suspense&gt; &lt;/div&gt; );}; Lazy Loading Routes 12345678const Home = lazy(() =&gt; import(&quot;./Home&quot;));const App = () =&gt; { return ( // ... &lt;Route exact component={Home} path=&quot;/&quot; /&gt; );}; 예제 12345678910111213141516171819202122import React, { Suspense, lazy } from &quot;react&quot;;import { Switch, BrowserRouter as Router, Route } from &quot;react-router-dom&quot;;const Home = lazy(() =&gt; import(&quot;./pages/Home&quot;));const SelectCity = lazy(() =&gt; import(&quot;./pages/SelectCity&quot;));const CityPage = lazy(() =&gt; import(&quot;./pages/City&quot;));const App = () =&gt; { return ( &lt;Router&gt; &lt;Suspense fallback={&lt;h1&gt;Loading...&lt;/h1&gt;}&gt; &lt;Switch&gt; &lt;Route exact component={Home} path=&quot;/&quot; /&gt; &lt;Route component={SelectCity} path=&quot;/select-city&quot; /&gt; &lt;Route component={CityPage} path=&quot;/:city&quot; /&gt; &lt;/Switch&gt; &lt;/Suspense&gt; &lt;/Router&gt; );};export default App; 컴포넌트 Preloading 특정 시점에 컴포넌트를 로딩하도록 하는 방법 (마우스 오버시, 부모 컴포넌트 로딩 완료 후) 1234567891011121314function lazyWithPreload(importFunction) { const Component = React.lazy(importFunction); Component.preload = importFunction; return Component;}const LazyImageModal = lazyWithPreLoad(() =&gt; import(&quot;./components/ImageModal&quot;));const App = () =&gt; { // ... useEffect(() =&gt; { LazyImageModal.preload(); }, []);}; 이미지 Preloading 이미지를 특정시점에 로딩하여 캐싱되도록 하고 캐싱된 이미지가 사용되도록 하는 방법 123456const App = () =&gt; { useEffect(() =&gt; { const img = new Image(); img.scr = &quot;이미지 주소&quot;; }, []);}; Promise를 사용한 이미지 Preloading 12345678910111213141516171819const cacheImages = async (scrArray) =&gt; { const promises = await srcArray.map((src) =&gt; { return new Promise(function (resolve, reject) { const img = new Image(); img.src = src; img.onload = resolve(); img.onerror = reject(); }); }); await Promise.all(promises);};const App = () =&gt; { useEffect(() =&gt; { const imgs = [&quot;image1.png&quot;, &quot;image2.png&quot;, &quot;image3.png&quot;]; cacheImages(imgs); }, []);};","link":"/2022/03/05/%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-part1/"},{"title":"[웹] 성능 최적화 - part 2","text":"이미지 지연로딩Interscetion Observer API를 사용하여 타켓 요소가 Viewport에 표시될 때 이미지를 로딩하여 불필요한 로딩을 줄일수 있다. 12345678910111213141516useEffect(() =&gt; { const options = {}; const callback = (entries, observer) =&gt; { entries.forEach((entry) =&gt; { if (entry.isIntersecting) { entry.target.src = entry.target.dataset.src; observer.unobserve(entry.target); } }); }; const observer = new IntersectionObserver(callback, options); observer.observe(imgRef.current);}, []);return &lt;img data-src={props.image} ref={imgRef} /&gt;; LazyImage 컴포넌트 1234567891011121314151617181920import React, { useEffect, useRef } from &quot;react&quot;;const LazyImage = ({ observer, src, alt }) =&gt; { const imageEl = useRef(null); useEffect(() =&gt; { const { current } = imageEl; if (observer !== null) { observer.observe(current); } return () =&gt; { observer.unobserve(current); }; }, [observer]); return &lt;img ref={imageEl} data-src={src} alt={alt} /&gt;;};export default LazyImage; 이미지 사이즈 최적화 WebP 포맷 이미지를 사용하여 이미지 로딩 속도 개선 WebP(Web Picture)는 GIF, JPG, PNG 이미지 포맷을 대치하기 위해 개발되었다. WebP를 사용하면 JPG는 기존 대비 2534%, PNG는 비손실의 경우 평균 26%(손실 방식의 경우 6070%) 정도 기존 파일 대비 작아진다고 한다. WebP는 HTML5 표준의 img 태그에서 사용할 수 있으며 대부분의 모던 브라우저에서 지원된다. 이미지 변환 사이트를 통해 이미지를 변환하고 사용한다.(https://squoosh.app/) picture 태그를 사용하여 WebP 미지원 브라우저에 이미지 대체 (Use WebP images) 1234&lt;picture&gt; &lt;source type=&quot;image/webp&quot; srcset=&quot;pic.webp&quot; /&gt; &lt;img src=&quot;pic.jpg&quot; alt=&quot;test&quot; /&gt;&lt;/picture&gt; 동영상 사이즈 최적화 WebM 포맷 동영상을 사용하여 동영상 로딩 속도 개선 WebM은 웹의 트래픽 감소를 주 목적으로 구글에서 개발해 오픈소스로 개발/운영되는 형식이다. 압축률이 높고 파일의 크기가 작아 웹기반의 사이트나 애플리케이션에서 전송속도 개선에도 효과적이다. WebM은 HTML5 표준의 video 태그에서 사용할 수 있으며 대부분의 모던 브라우저에서 지원된다. 동영상 변환 사이트를 통해 동영상을 변환하고 사용한다. (https://www.media.io/) video 태그를 사용하여 WebM 미지원 브라우저에 동영상 대체 (Video Tag) 12345&lt;video controls width=&quot;250&quot;&gt; &lt;source src=&quot;/media/cc0-videos/flower.webm&quot; type=&quot;video/webm&quot; /&gt; &lt;source src=&quot;/media/cc0-videos/flower.mp4&quot; type=&quot;video/mp4&quot; /&gt; Sorry, your browser doesn't support embedded videos.&lt;/video&gt; 폰트 최적화 폰트 적용 시점 컨트롤 하기 폰트 사이즈 줄이기 웹 폰트 사용과 최적화의 최근 동향 &gt; 웹폰트 최적화 하기 폰트 적용 시점 컨트롤 하기 브라우저는 웹페이지 렌더링시 웹폰트가 다운로드되지 않으면 텍스트 렌더링을 차단한다. FOIT(Flash Of Inivisible Text): 최초 텍스트가 보이지 않는 상태에서 폰트가 다운로드되면 텍스트가 표시되는 방식 FOUT(Flash Of Unstyled Text): 폴백 폰트가 표시되고 폰트가 다운로드되면 텍스트가 표시되는 방식 CSS font-display 속성으로 브라우저 렌더링 방식을 변경할 수 있다. 12345font-display: auto; // 브라우저에 의해 결정font-display: swap; // 폴백 폰트가 표시되고 로딩 완료되면 적용font-display: block; // 폰트가 표시되지 않고 로딩 완료되면 적용 (최대 3초)font-display: fallback; // ~100ms 까지 폰트 표시 안됨, ~3초 까지 폴백 폰트 표시 후 로딩 완료되면 적용font-display: optional; // ~100ms 까지 폰트 표시 안됨, 폴백 표시 후 로딩 완료시 네트워크 상태에 따라 폴백/웹폰트 적용 Font Observer 라이브러리 사용으로 폰트 로딩 표시 시점에 CSS 효과를 적용하여 UX 개선 Font Face Observer Font Face Observer React Hook 폰트 사이즈 줄이기웹폰트 포맷 사용 WOFF, WOFF2 포맷을 사용하여 폰트 사이즈 축소 (https://transfonter.org/) 파일 크기: EOT &gt; TTF/OTF &gt; WOFF &gt; WOFF2 123456789@font-face { font-family: &quot;Nanum Gothic&quot;; font-style: normal; font-weight: 400; src: url(/static_fonts/NanumGothic-Regular.eot), url(/static_fonts/NanumGothic-Regular.woff2) format(&quot;woff2&quot;), url(/static_fonts/NanumGothic-Regular.woff) format(&quot;woff&quot;), url(/static_fonts/NanumGothic-Regular.ttf) format(&quot;truetype&quot;);} Local 폰트 사용 사용자의 로컬환경에 설치된 폰트는 local() 이라는 구문을 사용하여 Local 폰트를 사용 123456@font-face { font-family: MyHelvetica; src: local(&quot;Helvetica Neue Bold&quot;), local(&quot;HelveticaNeue-Bold&quot;), url(MgOpenModernaBold.ttf); font-weight: bold;} Subset 사용 서브셋 폰트(subset font)는 폰트 파일에서 불필요한 글자를 제거하고 사용할 글자만 사용하는 폰트 적용 Unicode Range 적용 유니코드를 사용하여 폰트에서 사용할 특정 문자 범위를 설정하여 필요한 글자만 폰트 적용 data-uri로 변환 (Data-URI로 웹 폰트 사용하기) BASE64 encoding으로 폰트를 data-uri로 변환하여 CSS 로드시에 폰트를 로딩하여 속도를 개선 Preload를 폰트 로딩 개선preload 속성을 사용하여 CSS 파일보다 우선하여 폰트 로딩 1234567&lt;link rel=&quot;preload&quot; href=&quot;./nanumGothic.woff2&quot; as=&quot;font&quot; type=&quot;font/woff2&quot; crossorigin=&quot;anonymous&quot;/&gt; preload-webpack-plugin Preload, Prefetch And Priorities in Chrome 캐시 최적화서버에서 Response Header의 Cache-Control 속성을 컨트롤하여 캐싱을 최적화한다. HTTP caching Cache-Control 웹 서비스 캐시 똑똑하게 다루기 chromium disk cache Cache-control no-cache: 캐시를 사용하기 전에 서버에거 검사 후, 사용 결정 no-store: 캐시 사용 안함 public: 모든 환경에서 캐시 사용 가능 private: 브라우저 환경에서만 캐시 사용, 외부 캐시 서버에서는 사용 불가 (중간 서버에서 사용 안함) max-age: 캐시의 유효기간 (60 = 60초), 유효기간 만료후에는 서버에 검사 요청 후에 사용 결정 어떻게 리소스 변경을 식별하는가?etag 속성을 사용하여 리소스 변경을 식별한다. ETag HTTP 응답 헤더는 특정 버전의 리소스를 식별하는 식별자입니다. 웹 서버가 내용을 확인하고 변하지 않았으면, 웹 서버로 full 요청을 보내지 않기 때문에, 캐쉬가 더 효율적이게 되고, 대역폭도 아낄 수 있습니다. (ETag HTTP) 리소스 사용 구조브라우저는 최초에 HTML 파일을 로딩하고 HTML 구문을 해석하여 JS,CSS 파일과 IMG 파일을 로딩한다. 모던 웹 브라우저 들여다보기 일반적인 사용 방식 HTML을 서버에서 검사하고, 다른 리소스는 모든 서버에서 캐싱되도록 하고 유효기간은 최대로 설정한다. HTML을 제외한 리소스는 배포시에 새로운 hash값으로 변경된다면 항상 최신으로 유지가 가능하다. 12HTML: no-cacheCSS, JS, IMG: public, max-age=31536000 CDN에 캐싱을 유지하고 배포시에 CDN Invalidation을 발생하여 갱신하는 방식 s-maxage값으로 중간 서버에 캐싱을 유지하고 max-age=0(=no-cache)로 최신 파일을 확인한다. CDN에는 캐싱된 파일이 최대 유효기간으로 설정되어 있기때문에 배포후에 CDN Invalidation으로 최신 파일로 갱신해야 한다. 12HTML: max-age=0, s-maxage=31536000CSS, JS, IMG: public, max-age=31536000 Request Header는 언제 사용되는가?HTTP 요청에서 사용되지만 메시지의 컨텐츠와 관련이 없는 패치될 리소스나 클라이언트 자체에 대한 자세한 정보를 포함하는 헤더이다. 해당 요청을 통해 서버에서 클라이언트 요청 사항과 요청 정보를 파악할 수 있다. Host : 요청하려는 서버 호스트 이름과 포트번호 User-agent : 클라이언트 프로그램 정보 ex) Mozilla/4.0, Windows NT5.1 Referer : 현재 페이지로 연결되는 링크가 있던 이전 웹 페이지의 주소 Accept : 클라이언트가 처리 가능한 MIME Type 종류 나열 Accept-charset : 클라이언트가 지원가능한 문자열 인코딩 방식 Accept-language : 클라이언트가 지원가능한 언어 나열 Accept-encoding : 클라이언트가 해석가능한 압축 방식 지정 If-Modified-Since : 여기에 쓰여진 시간 이후로 변경된 리소스 취득. 캐시가 만료되었을 때에만 데이터를 전송하는데 사용 Authorization : 인증 토큰을 서버로 보낼 때 쓰이는 헤더 Origin : 서버로 Post 요청을 보낼 때 요청이 어느 주소에서 시작되었는지 나타내는 값. 경로 정보는 포함하지 않고 서버 이름만 포함 이 값으로 요청을 보낸 주소와 받는 주소가 다르면 CORS 에러가 난다. Cookie : 쿠기 값 key-value로 표현된다. Set-Cookie 헤더와 함께 서버로부터 이전에 전송됐던 저장된 HTTP 쿠키를 포함 불필요한 CSS 제거 빌드시점에 사용하지 않는 CSS를 제거하여 CSS 파일 사이즈 최소화한다. PurgeCSS를 사용하여 사용하지 않는 CSS를 제거 (https://purgecss.com/)","link":"/2022/03/11/%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-part2/"},{"title":"[자바스크립트] V8 엔진 및 JavaScript 최적화 팁","text":"원문으로 가기 Credit: Paul Ryan 이 포스트는 Paul Ryan가 작성한 The V8 Engine and JavaScript Optimization Tips를 번역한 내용이며, 임의로 첨삭한 부분이 있습니다. 모든 번역 포스트는 원작자의 동의를 받아 번역을 진행하였습니다. V8은 JavaScript를 컴파일하기 위한 Google의 엔진입니다. Firefox에는 SpiderMonkey라는 자체 엔진이 있으며 V8과 매우 유사하지만 차이점이 있습니다. 이 포스트에서는 V8 엔진에 대해 논의할 것입니다. V8 엔진에 대한 몇 가지 사실: C++로 작성되고 Chrome 및 Node.js (및 Microsoft Edge의 최신 릴리스) 에서 사용됨 ECMA-262에 지정된 대로 ECMAScript를 구현합니다. JavaScript 살펴보기그렇다면 V8 엔진에 의해 구문 분석되도록 JavaScript(JavaScript 코드에 대해 minified, uglified 및 기타 다른 작업을 수행한 후)를 보내면 어떤일이 벌어질 까요?모든 단계를 보여주는 다음 다이어그램을 만들었습니다. 각 단계에 대해 자세히 살펴 보겠습니다. 이 포스트에서는 JavaScript 코드가 구문 분석되는 방법과 가능한 한 많은 JavaScript를 Optimizing Compiler로 가져오는 방법에 대해 설명합니다. 최적화 컴파일러(Turbofan)는 자바스크립트 코드를 가져다가 고성능 머신 코드로 변환하므로 더 많은 코드를 제공할수록 응용 프로그램의 속도가 빨라집니다. 참고로, 크롬의 인터프리터를 Ignition이라고 합니다. JavaScript 파싱JavaScript 코드의 첫 번째 처리는 이를 구문 분석하는 것입니다. 파싱(parsing)이 정확히 무엇인지 논의해 봅시다.구문 분석에는 다음과 같은 두 단계가 있습니다. Eager(전체 구문 분석) - 각 라인을 즉시 구문 분석합니다. Lazy(사전 구문 분석) - 최소한의 작업만 수행하고 필요한 구문 분석을 수행하고 나머지는 나중으로 미룹니다. 어떤게 더 좋을까요? 그것은 상황에 따라 다릅니다. 몇 가지 코드를 살펴보겠습니다. 1234567891011// eager parse declarations right awayconst a = 1;const b = 2;// lazily parse this as we don't need it right awayfunction add(a, b) { return a + b;}// oh looks like we do need add so lets go back and parse itadd(a, b);","link":"/2022/03/19/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-V8-%EC%97%94%EC%A7%84-%EB%B0%8F-JavaScript-%EC%B5%9C%EC%A0%81%ED%99%94/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","link":"/tags/Leetcode/"},{"name":"Coding Interview","slug":"Coding-Interview","link":"/tags/Coding-Interview/"},{"name":"Blockchain","slug":"Blockchain","link":"/tags/Blockchain/"},{"name":"Cryptocurrency","slug":"Cryptocurrency","link":"/tags/Cryptocurrency/"},{"name":"Bitcoin","slug":"Bitcoin","link":"/tags/Bitcoin/"},{"name":"Solidity","slug":"Solidity","link":"/tags/Solidity/"},{"name":"Security","slug":"Security","link":"/tags/Security/"},{"name":"Book","slug":"Book","link":"/tags/Book/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Optimization","slug":"Optimization","link":"/tags/Optimization/"}],"categories":[{"name":"Coding Interview","slug":"Coding-Interview","link":"/categories/Coding-Interview/"},{"name":"Blockchain","slug":"Blockchain","link":"/categories/Blockchain/"},{"name":"String Manipulation","slug":"Coding-Interview/String-Manipulation","link":"/categories/Coding-Interview/String-Manipulation/"},{"name":"Solidity","slug":"Solidity","link":"/categories/Solidity/"},{"name":"Security","slug":"Solidity/Security","link":"/categories/Solidity/Security/"},{"name":"Book","slug":"Book","link":"/categories/Book/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Optimization","slug":"Web/Optimization","link":"/categories/Web/Optimization/"}]}