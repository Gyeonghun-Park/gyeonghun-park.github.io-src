---
title: '[Solidity] 솔리디티, EVM, Opcode, Bytecode'
tags: [Blockchain, Solidity]
toc: true
widgets:
  - type: toc
    position: left
  - type: categories
    position: right
cover: /img/solidity.jpeg
date: 2022-01-04 10:58:15
categories: [Solidity]
---

</pre>

<!--more-->

<!--more-->

## **솔리디티**

솔리디티(Solidity)는 이더리움 등 블록체인 플랫폼에서 스마트 컨트랙트 작성과 구현에 사용되는 컨트랙트 지향 프로그래밍 언어이다. C++, 파이썬, 자바스크립트의 영향을 받은 고수준 언어이다. 이더리움 가상머신(Ethereum Virtual Machine)이라는 EVM을 타깃으로 디자인된 솔리디티는 이더리움 가상머신에서 작동 가능한 바이트코드로 컴파일된다. 솔리디티는 정적 타입(statically-typed)이고 여러 기능 중 상속, 라이브러리, 유저 정의 타입을 지원한다.

튜링완전이라는 특성을 가진 솔리디티는 반복문과 제어문을 사용할 수 있다. 솔리디티는 하나의 컨트랙트 내에서 다중 타입의 안전한 함수가 가능하게 하는 '응용 이진 인터페이스'(ABI; application binary interface)가 포함된다.

---

## **이더리움 가상머신**

이더리움 가상머신은 스마트 콘트랙트 배포 및 실행을 처리하는 이더리움의 일부다. 하나의 외부 소유 계정(External Owned Account)에서 다른 외부 소유 계정으로 간단한 값을 전송하는 트랜잭션은 이더리움 가상머신이 필요 없지만, 그 외 모든 것은 이더리움 가상머신에 의한 상태 업데이트를 수반한다. 크게 보면 이더리움 블록체인에서 실행되는 이더리움 가상머신은 자체 영구 데이터 저장소가 있는 수백만 개의 실행 가능 객체를 가진 전 세계에서 탈중앙화된 컴퓨터다.

이더리움 가상머신(EVM)을 통해 모든 노드들의 컴퓨터에서 동일한 연산을 수행함으로 동일한 상태(state)에 합의한다. 이더리움은 전 세계 모든 참가자가 동일한 하나의 컴퓨터를 돌리는 것과 같기 때문에 '세계 컴퓨터'(world computer)라고 불리기도 한다

스마트 콘트랙트 실행에 사용할 수 있는 가스양에 따라 모든 실행 프로세스가 유한개의 계산 단계로 제한된다는 것을 의미한다. 이더리움 가상머신은 메모리 내의 모든 값을 스택에 저장하는 스택 기반 아키텍처로 256비트의 단어 크기로 동작하며, 주소 지정이 가능한 여러 개의 데이터 구성 요소를 가지고 있다. 실행할 스마트 콘트랙트의 바이트 코드가 저장되는 불변 프로그램 코드 롬, 모든 위치가 0으로 초기화하는 파괴성 메모리, 이더리움 상태의 일부인 영구 저장소가 이에 해당한다. 이더리움 가상머신의 명령어 집합에는 산술 및 비트 논리 연산, 실행 콘트랙트 세트 조회, 스택, 메모리, 스토리지 접근, 흐름 제어 작업, 로깅, 호출, 기타연산자 등이 있다.

---

## **Opcode**

이더리움 컨트랙트의 코드는 낮은 수준(low-level)의 스택 기반(stack-based) 바이트코드 언어로 작성되어 있다. 옵코드(Opcode)는 사람들이 읽기편한 형태의 낮은 수준의 명령어 이다. 모든 opcode는 해당하는 16진수 값을 갖는다. 

예를 들어 "`mstore`"는 "`0x52`", "`sstore`"는 "`0x55`"이다. 현재는 140개의 고유한 Opcode가 존재한다.

![옵코드 정리](/img/솔리디티-EVM-Opcode-Bytecode/1.png?style=centerme)

---

## **Bytecode**

Opcode를 효율적으로 저장하고 EVM이 읽기 가능하게 만들려면 bytecode로 저장될 필요가 있다. 

예를들어, 만약 `0x6001600101`이라는 bytecode가 있다. 이러한 bytecode는 1바이트 크기로 나누어 의미를 가진다. 

첫번째 명령어인 Opcode의 0x60은 PUSH1으로 번역된다. `PUSH1`은 값을 스택에 저장하므로, `[ 0x01 ]`이 스택에 저장된다. 이렇게 스택에는 하나의 아이템이 저장되며 다음 명령어로 넘어가게 된다. 

다음 명령어도 같은 `0x6001`이므로 스택에는 `[ 0x01, 0x01 ]`이 저장되어 있다. 

마지막 명령어는 `0x01`이며 이는 `ADD`로 번역된다. 따라서 스택 안에 있는 두개의 데이터를 더해서 스택에 넣고, 최종 결과는 스택에 `[ 0x02 ]`가 저장 되어있다.

![바이트코드 시각화](/img/솔리디티-EVM-Opcode-Bytecode/2.png?style=centerme)